[{"title":"oracle数据库日常使用总结","date":"2017-01-18T13:30:42.000Z","path":"2017/01/18/oracle数据库日常使用总结/","text":"oracle数据库日常使用总结decode函数的使用使用规则：decode(条件,值1,返回值1,值2,返回值2,…值n,返回值n,缺省值) 方法原理：12345678910IF 条件=值1 THEN RETURN(翻译值1)ELSIF 条件=值2 THEN RETURN(翻译值2) ......ELSIF 条件=值n THEN RETURN(翻译值n)ELSE RETURN(缺省值)END IF Decode函数与一系列嵌套的 IF-THEN-ELSE语句相似。但是使用更加便捷简单。开发中主要可用于： 1. 对不同取值的数据进行计数 在统计策略项目的成功和失败情况时，直接使用Count函数无法完成分别统计成功和失败的次数。此时可以使用sum函数和decode函数结合，例如SUM (DECODE(H.SERVICE_STATUS,&#39;1&#39;,1，0)) AS SUCCESS，若H.SERVICE_STATUS为’1’（其中’1’表示成功），则返回数字1，通过sum函数进行求和，即可求得所有SERVICE_STATUS为’1’的次数 2. 将当前值翻译为其他值 由上例已经可以看出，在使用DECODE(H.SERVICE_STATUS,&#39;1&#39;,1，0)时，将字符型的1翻译为了数字1，使其可以进行求和操作 字符串拼接操作同一条数据中不同列的字符串之间进行拼接操作oracle中可以使用||和CONCAT两种方式进行字符串拼接 使用||方式：&#39;字符串1&#39; || &#39;字符串2&#39; || &#39;字符串3&#39; || &#39;字符串4&#39; 注意：这种方式进适用于oracle数据库，在MySQL或其他数据库中不能采用这种方式 使用CONCAT方式：SELECT CONCAT(&#39;字符串1&#39;,&#39;字符串2&#39;) FROM TableName 注意：CONCAT()在oracle中只能拼接两个字符串，如果需要拼接多个字符串，可采用多个CONCAT()嵌套拼接多个字符串。但在MySQL中，CONCAT()函数是可以同时拼接多个字符串的，用法如下 `SELECT CONCAT(&apos;字符串1&apos;,&apos;字符串2&apos;,&apos;字符串3&apos;,&apos;字符串4&apos;) FROM TableName` 字符串聚合拼接操作常用的有 WMSYS.WM_CONCAT （从oracle 10G开始支持） LISTAGG(measure_expr,delimiter) WITHIN GROUP(order_by_clause) OVER(query_partition_clause) （从oracle 11G R2开始支持） SYS_CONNECT_BY_PATH （从oracle 9i开始支持）WMSYS.WM_CONCAT用法123select wmsys.wm_concat(colname1) from TableNamegroup by colname2; 默认分隔符为逗号,如果想替换为其他分隔符，可采用如下方法123select replace(wmsys.wm_concat(colname1),&apos;,&apos;,&apos;、&apos;) from TableNamegroup by colname2; 其余两种情况后续补充","tags":[{"name":"oracle","slug":"oracle","permalink":"https://songjin1994.github.io/tags/oracle/"},{"name":"数据库","slug":"数据库","permalink":"https://songjin1994.github.io/tags/数据库/"}]},{"title":"Extjs框架总结","date":"2017-01-18T13:29:22.000Z","path":"2017/01/18/Extjs框架总结/","text":"Extjs框架知识总结概述Ext是基于Web的富客户端框架，其完全是基于标准W3C技术构建的，使用到的都是HTML、CSS、DIV等相关技术。Extjs提供了大量已经封装好的可以直接使用的组件，上手容易。以下是基于Extjs框架整合的demo。 Extjs框架可分为五个部分： HTML页面：加载js插件，承载界面显示 Controller.js：控制各个组件，以及实现事件监听 View.js：实现页面的布局 Store.js：提供数据信息，可以通过代理向后台获取表单数据 Model.js：数据保存模块，用于保存Store获取的数据 以下是各个模块实现是代码示例：HTML页面：12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;/&gt; &lt;title&gt;Extjs示例&lt;/title&gt; &lt;link href=&quot;ext-4.2/resources/css/ext-all-gray.css&quot; rel=&quot;stylesheet&quot;/&gt; &lt;link href=&quot;resources/css/icon.css&quot; rel=&quot;stylesheet&quot;/&gt; &lt;script src=&quot;ext-4.2/ext-all.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;ext-4.2/locale/ext-lang-zh_CN.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;common.js&quot;&gt;&lt;/script&gt; &lt;style type=&quot;text/css&quot;&gt; .photo_css1 &#123; height: 18px; width: 66px; cursor: pointer; &#125; .photo_css2 &#123; display: none; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;script&gt; Ext.application(&#123; name: &apos;Cnu&apos;, controllers: [&apos;Cnu.controller.CheckSummaryController&apos;], launch: function () &#123; Ext.create(&apos;Ext.container.Viewport&apos;, &#123; layout: &apos;fit&apos;, items: [&#123; xtype: &apos;CheckSummaryView&apos; &#125;] &#125;); &#125; &#125;);&lt;/script&gt;&lt;/html&gt; Controller.js 1234567891011121314151617181920212223242526272829303132333435363738394041Ext.define(&quot;Cnu.controller.CheckSummaryController&quot;, &#123; extend: &apos;Ext.app.Controller&apos;, views: [&apos;demo.CheckSummaryView&apos;], models: [&apos;demo.CheckSummaryModel&apos;], stores: [&apos;demo.CheckSummaryStore&apos;], refs: [ &#123; ref: &apos;CheckSummaryView&apos;, selector: &apos;CheckSummaryView&apos; &#125; ], init: function () &#123; this.control(&#123; &apos;CheckSummaryView button&apos;: &#123; click: this.btnEvent &#125; &#125;); &#125; , btnEvent: function (selModel) &#123; var grid = this.getCheckSummaryView(); //var model = grid.getSelectionModel(); if (selModel.iconCls == &quot;icon-query&quot;) &#123;//查询 //点击搜索按钮将查询条件传递到后台// model.clearSelections();//清空所有选择 var jobId = Ext.getCmp(&apos;jobId&apos;).getValue(); var startTime = Ext.util.Format.date(Ext.getCmp(&apos;startTime&apos;).getValue(), &apos;Y-m-d&apos;); var endTime = Ext.util.Format.date(Ext.getCmp(&apos;endTime&apos;).getValue(), &apos;Y-m-d&apos;); var deptType = Ext.getCmp(&apos;deptType&apos;).getValue(); //store 加载之前将参数放进去以待后台获取 grid.store.on(&apos;beforeload&apos;, function (store, options) &#123; var new_params = &#123;jobId: jobId, startTime: startTime, endTime: endTime,deptType: deptType&#125;; Ext.apply(store.proxy.extraParams, new_params); &#125;); grid.store.load(); &#125; &#125;&#125;); View.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145Ext.define(&quot;Cnu.view.demo.CheckSummaryView&quot;, &#123; extend: &apos;Ext.grid.Panel&apos;, xtype: &apos;CheckSummaryView&apos;, store: &apos;demo.CheckSummaryStore&apos;, initComponent: function () &#123; //顶部工具栏 查询输入框 this.tbar = [ &#123; xtype: &apos;label&apos;, text: &apos;工号：&apos; &#125;, &#123; xtype: &apos;textfield&apos;, id: &apos;jobId&apos;, emptyText: &apos;请输入工号&apos; &#125;, &#123; id:&apos;startTime&apos;, xtype : &apos;datefield&apos;, //anchor: &apos;100%&apos;, name : &apos;startTime&apos;, //hiddenName : &apos;bdate&apos;, fieldLabel : &apos;起始时间:&apos;, format: &apos;Y-m-d&apos;, allowBlank : false, listeners: &#123; change: function () &#123; var e = Ext.util.Format.date(Ext.getCmp(&apos;endTime&apos;).getValue(), &apos;Y-m-d&apos;);//格式化日期控件值 var s = Ext.util.Format.date(Ext.getCmp(&apos;startTime&apos;).getValue(), &apos;Y-m-d&apos;);//格式化日期控件值 var end = new Date(e); var start = new Date(s); var today = new Date(); if(start.getTime()&gt;today.getTime())&#123; Ext.Msg.alert(&quot;提示：&quot;,&quot;不可大于当前时间！&quot;); Ext.getCmp(&apos;startTime&apos;).setValue(null); &#125;else if(end.getTime() &lt; start.getTime()) &#123; Ext.Msg.alert(&quot;提示&quot;,&quot;结束时间必须大于开始时间！&quot;); Ext.getCmp(&apos;startTime&apos;).setValue(null); &#125;else if((today.getTime()-start.getTime())/86400000&gt;31)&#123; Ext.Msg.alert(&quot;提示：&quot;,&quot;只能查询最近30天的数据！&quot;); Ext.getCmp(&apos;startTime&apos;).setValue(null); &#125; &#125; &#125;, value: new Date() // defaults to today &#125;, //&#123;xtype:&apos;spacer&apos;, width:100&#125;, &#123; id:&apos;endTime&apos;, xtype : &apos;datefield&apos;, //anchor: &apos;100%&apos;, name : &apos;endTime&apos;, fieldLabel : &apos;截止时间:&apos;, format: &apos;Y-m-d&apos;, allowBlank : false, listeners: &#123; change: function () &#123; var e = Ext.util.Format.date(Ext.getCmp(&apos;endTime&apos;).getValue(), &apos;Y-m-d&apos;);//格式化日期控件值 var s = Ext.util.Format.date(Ext.getCmp(&apos;startTime&apos;).getValue(), &apos;Y-m-d&apos;);//格式化日期控件值 var end = new Date(e); var start = new Date(s); var today = new Date(); if(end.getTime()&gt;today.getTime())&#123; Ext.Msg.alert(&quot;提示：&quot;,&quot;不可大于当前时间！&quot;); Ext.getCmp(&apos;endTime&apos;).setValue(null); &#125;else if(end.getTime() &lt; start.getTime()) &#123; Ext.Msg.alert(&quot;提示&quot;,&quot;结束时间必须大于开始时间！&quot;); Ext.getCmp(&apos;endTime&apos;).setValue(null); &#125;else if((today.getTime()-end.getTime())/86400000&gt;31)&#123; Ext.Msg.alert(&quot;提示：&quot;,&quot;只能查询最近30天的数据！&quot;); Ext.getCmp(&apos;endTime&apos;).setValue(null); &#125; &#125; &#125;, value: new Date() // defaults to today &#125;, &#123; id:&apos;deptType&apos;, xtype: &apos;combobox&apos;, fieldLabel: &apos;组织结构:&apos;, name: &apos;deptType&apos;, //hiddenName: &apos;STRATEGY_TYPE&apos;, store: Ext.create(&apos;Ext.data.Store&apos;, &#123; fields: [&apos;DEPARTMENT&apos;, &apos;DEPARTMENT_DESC&apos;], autoLoad:true, proxy: &#123; type: &apos;rest&apos;, url: rest_prefix+&apos;/checksummary/getDept&apos;, reader: &#123; type: &apos;json&apos;, root: &apos;DATA&apos; &#125; &#125; &#125;), valueField: &apos;DEPARTMENT&apos;, displayField: &apos;DEPARTMENT_DESC&apos;, typeAhead: true, queryMode: &apos;local&apos;, editable:false, allowBlank : false, triggerAction: &apos;all&apos;, emptyText: &apos;请选择组织结构...&apos; &#125;, &#123; text: &apos;查询&apos;, iconCls: &apos;icon-query&apos; &#125; ]; this.columns = [ &#123; header: &apos;工号&apos;, dataIndex: &apos;LOGIN_ID&apos;, flex: 1 &#125;, &#123; header: &apos;姓名&apos;, dataIndex: &apos;LOGIN_NAME&apos;, flex: 1.2 &#125;, &#123; header: &apos;签入已签出次数&apos;, dataIndex: &apos;LOGIN_NUM&apos;, flex: 2 &#125;, &#123; header: &apos;签入已签出时长（小时）&apos;, dataIndex: &apos;LOGIN_TIME&apos;, flex: 1.1 &#125; ]; this.callParent(arguments); &#125;, dockedItems: [ &#123; xtype: &apos;pagingtoolbar&apos;, store: &apos;demo.CheckSummaryStore&apos;, dock: &apos;bottom&apos;, displayInfo: true &#125; ]&#125;); Store.js 12345678910111213141516171819202122232425262728293031323334Ext.define(&quot;Cnu.store.demo.CheckSummaryStore&quot;, &#123; extend: &apos;Ext.data.Store&apos;, model: &apos;Cnu.model.demo.CheckSummaryModel&apos;, pageSize: &apos;15&apos;, autoSync: true, autoLoad: false, remoteFilter: true, remoteSort: true, proxy: &#123; type: &apos;rest&apos;, url: rest_prefix + &apos;/checksummary/checksummarylist&apos;, //actionMethods: &#123; // read: &apos;POST&apos; //&#125;, reader: &#123; type: &apos;json&apos;, root: &apos;DATA&apos;, totalProperty: &apos;totalCount&apos; &#125;, writer: &#123; type: &apos;json&apos; &#125; &#125;, /*sorters: [&#123;property: &apos;CREATE_TIME&apos;, direction: &apos;DESC&apos;&#125;],*/ listeners: &#123; &apos;beforeload&apos;: function (store, op, options) &#123; /*var params = &#123; isUse: 0 &#125;; Ext.apply(store.proxy.extraParams, params);*/ &#125; &#125;&#125;); Model.js123456789101112131415161718192021Ext.define(&apos;Cnu.model.demo.CheckSummaryModel&apos;, &#123; extend: &apos;Ext.data.Model&apos;, fields: [ &#123; name: &apos;LOGIN_ID&apos; &#125;, &#123; name: &apos;LOGIN_NAME&apos; &#125;, &#123; name: &apos;LOGIN_NUM&apos; &#125;, &#123; name: &apos;LOGIN_TIME&apos; &#125; ], idProperty: &apos;LOGIN_ID&apos;&#125;); 后台代理部分具体实现略","tags":[{"name":"ExtJs","slug":"ExtJs","permalink":"https://songjin1994.github.io/tags/ExtJs/"}]},{"title":"maven使用jetty插件","date":"2017-01-09T04:07:53.000Z","path":"2017/01/09/maven-jetty/","text":"maven使用jetty插件引入插件由于spring4.3版本不兼容jetty websocket组件，所以选择9.3版本 1234567891011&lt;plugin&gt; &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt; &lt;artifactId&gt;jetty-maven-plugin&lt;/artifactId&gt; &lt;version&gt;9.3.14.v20161028&lt;/version&gt; &lt;configuration&gt; &lt;scanIntervalSeconds&gt;10&lt;/scanIntervalSeconds&gt; &lt;webApp&gt; &lt;contextPath&gt;/&lt;/contextPath&gt; &lt;/webApp&gt; &lt;/configuration&gt;&lt;/plugin&gt; 添加servlet依赖用于编译servlet 12345&lt;dependency&gt; &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt; &lt;artifactId&gt;jetty-servlet&lt;/artifactId&gt; &lt;version&gt;9.3.14.v20161028&lt;/version&gt;&lt;/dependency&gt; 使用命令jetty:runrun目标允许你把你未打包的web应用部署到Jetty.它包含在你的pom.xml文件的一部分元素里。下面额外的配置参数都是可用到的： classesDirectory 这是你的web应用编译的classes存放的路径。你很少需要设置这个参数，其实可以在你的pom.xml用替代它。 webAppSourceDirectory 默认设置在${basedir}/src/main/webapp下。如果你的源文件夹结构跟左边不同，就可以设置这个参数。 webXml 默认设置在${maven.war.webxml}或者${basedir}/src/main/webapp/WEB-INF/web.xml，无论哪个文件都不是空的。如果觉得前两者都不合适，就设置它。 jettyEnvXml 可选。它指向一个jetty-env.xml文件的路径。允许你创建JNDI绑定并满足web.xml中、和元素中的条件。当然这个文件的使用范围仅仅在你的当前应用和其他应用同时部署时它并没有共享的情况下。(例如使用一个jettyConfig文件) scanTargets 可选。周期性的扫描除了插件自动扫描外的文件和文件夹列表。 scanTargetPatterns 可选。如果你想扫描有一长串的额外文件，通过使用模式匹配表达式制定它们更加方便，它可以用来替代 参数的枚举展示。这个参数包含一组。每一个都是由一个和[或者]参数来指定文件的匹配模式。","tags":[{"name":"maven","slug":"maven","permalink":"https://songjin1994.github.io/tags/maven/"}]},{"title":"Spring之JDBC","date":"2016-12-07T03:37:41.000Z","path":"2016/12/07/Spring之JDBC/","text":"Spring之JDBC简述针对繁琐的JDBC数据库连接配置（需要手动处理大量的异常和打开关闭各种流，例如connection，statement，resultset等）。Spring提供了一组数据访问框架，来消除持久化代码中那些枯燥的数据访问逻辑。Spring集成了多种数据访问技术，可以整合JDBC或者其他ORM框架，此处主要介绍基于JDBC的数据库访问方式。 补充：直接使用原生jdbc方式流程如下（以mysql为例） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import java.sql.*;public class JdbcTest &#123; public static final String URL = \"jdbc:mysql://localhost:3306/baron\"; public static final String USERNAME = \"root\"; public static final String PASSWORD = \"songjin\"; public static void main(String[] args) &#123; Connection connection = null; Statement statement = null; ResultSet resultSet = null; try &#123; Class.forName(\"com.mysql.jdbc.Driver\"); connection = DriverManager.getConnection(URL,USERNAME,PASSWORD); statement = connection.createStatement(); resultSet = statement.executeQuery(\"SELECT * FROM filerecord\"); while (resultSet.next())&#123; System.out.println(\"id---&gt;\" + resultSet.getInt(1)); System.out.println(\"md5---&gt;\" + resultSet.getString(2)); System.out.println(\"filename---&gt;\" + resultSet.getString(3)); System.out.println(\"path---&gt;\" + resultSet.getString(4)); System.out.println(\"-----------------------------------------------\"); &#125; &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;finally &#123; if (resultSet != null)&#123; try &#123; resultSet.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (statement != null)&#123; try &#123; statement.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (connection != null)&#123; try &#123; connection.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 关键类库使用Spring的JDBC框架，需要导入的包有： JDBC连接的jar包，以mysql为例，导入mysql-connector-java相应的包 导入Spring-JDBC相关的框架包org.springframework.jdbc包 简单上手配置数据源使用Spring的JDBC框架很简单，只需要为其注入一个数据源即可，Spring允许使用JNDI数据源、各种数据源连接池（例如dbcp、c3p0、BoneCP等）以及基于JDBC驱动的数据源。 以dbcp2数据连接池为例，简单配置如下： 12345&lt;bean id=\"dataSource\" class=\"org.apache.commons.dbcp2.BasicDataSource\" destroy-method=\"close\" p:driverClassName=\"com.mysql.jdbc.Driver\" p:url=\"jdbc:mysql://localhost:3306/baron\" p:username=\"root\" p:password=\"password\"/&gt; 配置JDBC模板Spring提供了三个JDBC模板： JdbcTemplate：最基本的SpringJDBC模板，支持简单的JDBC数据库访问功能以及基于索引参数的查询 NamedParameterJdbcTemplate：使用此模板执行查询时可以将值以命名参数的形式绑定到SQL中，而不是使用简单的索引参数 SimpleJdbcTemplate：该模板利用Java5的一些新特性例如自动装箱、泛型、以及可变参数列表来简化JDBC模板的使用（这种模板已经废弃，其特性全部转移到了JdbcTemplate中） 接下来把dataSource注入到模板中，配置如下 12&lt;bean id=\"jdbcTemplate\" class=\"org.springframework.jdbc.core.JdbcTemplate\" c:dataSource-ref=\"dataSource\"/&gt; 通过构造器注入到JdbcTemplate中。 使用JdbcTemplate查询数据测试代码如下： 123456789101112131415161718192021222324252627282930313233343536import model.FileRecord;import org.apache.commons.logging.Log;import org.apache.commons.logging.LogFactory;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import java.util.List;import java.util.Map;@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = &#123;\"classpath:conf/beans.xml\"&#125;)public class SpringJdbc &#123; Log log = LogFactory.getLog(SpringJdbc.class); @Autowired private JdbcTemplate jdbcTemplate; public JdbcTemplate getJdbcTemplate() &#123; return jdbcTemplate; &#125; public void setJdbcTemplate(JdbcTemplate jdbcTemplate) &#123; this.jdbcTemplate = jdbcTemplate; &#125; @Test public void selectTest()&#123; //查询一行数据 FileRecord fileRecord = jdbcTemplate.queryForObject(\"select * from filerecord where id = ?\",(rs,rouNum) -&gt; new FileRecord(rs.getLong(1),rs.getString(2),rs.getString(3),rs.getString(4)),7); log.debug(fileRecord); //查询多组数据，每一组数据为一个 List&lt;Map&lt;String,Object&gt;&gt; list = jdbcTemplate.queryForList(\"SELECT * FROM filerecord\"); list.forEach(x -&gt; System.out.println(x)); //查询多组数据，但每组只有一列数据 List&lt;String&gt; list1 = jdbcTemplate.queryForList(\"SELECT filename FROM filerecord\",String.class); list1.forEach(x -&gt; System.out.println(x)); &#125;&#125; queryForObject方法其中核心的地方在于lambda表达式的地方 (rs,rouNum) -&gt; new FileRecord(rs.getLong(1),rs.getString(2),rs.getString(3),rs.getString(4)),7) 在这里实际上是实现了一个RowMapper接口，如下所示： 12345678package org.springframework.jdbc.core;import java.sql.ResultSet;import java.sql.SQLException;public interface RowMapper&lt;T&gt; &#123; T mapRow(ResultSet var1, int var2) throws SQLException;&#125; 由于该接口满足函数式接口的特性，只有一个抽象方法，所以可以使用lambda表达式进行简写，通过实现mapRow（）方法，将获得的ResultSet中的值注入到FileRecord类中。 queryForList该方法有许多的重载，主要可以分为两种， 获取单列数据（SingleColumn）的List，单列数据需要传入一个class类作为返回的数据类型 获取多列数据返回的是一个List&lt;Map&lt;String,Object&gt;&gt;类型的数据，其中查询数据的每一行对应一个Map，每个Map中的Key对应列名，Value对应其相应的值 query所有的查询，如上的queryForObject和queryForList，以及例如queryForLong、queryForInt实际上最终都是调用query方法进行查询，具体方法详细可以查看源码或者文档。 以下介绍一种本人常使用的重载方法，用于实现查询多行数据并自动注入到FileRecord中。 该方法的api文档描述如下： 12345678910111213141516public &lt;T&gt; List&lt;T&gt; query(String sql, RowMapper&lt;T&gt; rowMapper, Object... args) throws DataAccessExceptionDescription copied from interface: JdbcOperationsQuery given SQL to create a prepared statement from SQL and a list of arguments to bind to the query, mapping each row to a Java object via a RowMapper.Specified by:query in interface JdbcOperationsParameters:sql - SQL query to executerowMapper - object that will map one object per rowargs - arguments to bind to the query (leaving it to the PreparedStatement to guess the corresponding SQL type); may also contain SqlParameterValue objects which indicate not only the argument value but also the SQL type and optionally the scaleReturns:the result List, containing mapped objectsThrows:DataAccessException - if the query fails 12List&lt;FileRecord&gt; list2 = jdbcTemplate.query(\"select * from filerecord\",(rs,rouNum) -&gt; new FileRecord(rs.getLong(1),rs.getString(2),rs.getString(3),rs.getString(4)));list2.forEach(x -&gt; System.out.println(x)); 此处并没有明确声明RowMapper指定泛型的类型，但仍然可以正确返回FileRecord类型的数据，是由于java8 lambda表达式强大的联系上下文推测数据类型的功能。 如果按照传统的写法将相当繁琐，必须先定义一个实现RowMapper的类，然后再对其实例化，并不推荐此方法，如下所示： 1234567891011public void oldMethod()&#123; List&lt;FileRecord&gt; list2 = jdbcTemplate.query(\"select * from filerecord\",new FilerecordRowMapper()); list2.forEach(x -&gt; System.out.println(x));&#125;class FilerecordRowMapper implements RowMapper&lt;FileRecord&gt;&#123; @Override public FileRecord mapRow(ResultSet rs, int i) throws SQLException &#123; return new FileRecord(rs.getLong(1),rs.getString(2),rs.getString(3),rs.getString(4)); &#125;&#125; 使用JdbcTemplate修改数据1234567891011121314public int update(String sql, Object... args) throws DataAccessExceptionDescription copied from interface: JdbcOperationsIssue a single SQL update operation (such as an insert, update or delete statement) via a prepared statement, binding the given arguments.Specified by:update in interface JdbcOperationsParameters:sql - SQL containing bind parametersargs - arguments to bind to the query (leaving it to the PreparedStatement to guess the corresponding SQL type); may also contain SqlParameterValue objects which indicate not only the argument value but also the SQL type and optionally the scaleReturns:the number of rows affectedThrows:DataAccessException - if there is any problem issuing the update 插入、修改、删除均可使用该方法完成，略。","tags":[{"name":"Spring","slug":"Spring","permalink":"https://songjin1994.github.io/tags/Spring/"},{"name":"JDBC","slug":"JDBC","permalink":"https://songjin1994.github.io/tags/JDBC/"}]},{"title":"Linux相关","date":"2016-11-10T15:09:19.000Z","path":"2016/11/10/Linux相关/","text":"Linux相关配置163软件源修改/etc/apt/sources.list文件内容如下所示： 12345678deb http://mirrors.163.com/debian/ jessie main non-free contribdeb http://mirrors.163.com/debian/ jessie-updates main non-free contribdeb http://mirrors.163.com/debian/ jessie-backports main non-free contribdeb-src http://mirrors.163.com/debian/ jessie main non-free contribdeb-src http://mirrors.163.com/debian/ jessie-updates main non-free contribdeb-src http://mirrors.163.com/debian/ jessie-backports main non-free contribdeb http://mirrors.163.com/debian-security/ jessie/updates main non-free contribdeb-src http://mirrors.163.com/debian-security/ jessie/updates main non-free contrib 然后执行apt update命令即可修改软件源 使用vi编辑器方向键变ABCD且backspace无法使用","tags":[{"name":"Linux","slug":"Linux","permalink":"https://songjin1994.github.io/tags/Linux/"}]},{"title":"JavaWeb基础知识点总结","date":"2016-11-07T07:04:36.000Z","path":"2016/11/07/JavaWeb基础知识点总结/","text":"JavaWeb基础知识点总结JSP相关4种基本语法JSP注释JSP声明输出JSP表达式JSP脚本三种编译指令page指令include指令taglib指令7个动作指令jsp:forwardjsp:paramjsp:includejsp:pluginjsp:useBeanjsp:setPropertyjsp:getProprtty9个内置对象applicationapplication是javax.servlet.ServletContext的实例，代表jsp所属的Web应用自身，用于jsp或者Servlet之间交换信息 setAttribute(String attrName,Object value)方法：将一个值设置成application范围的属性，属性值对整个web应用有效 getAttribute(String attrName)方法：通过属性名获取一个application范围的属性值 获取web应用配置参数：使用application的getInitParameter(String paramName)获取web应用的配置参数，这些配置参数应该在web.xml文件中使用context-param元素配置，格式如下 1234&lt;context-param&gt; &lt;param-name&gt;参数名&lt;/param-name&gt; &lt;param-value&gt;参数值&lt;/param-value&gt;&lt;/context-param&gt; ​ configconfig对象是javax.servlet.ServletConfig的实例，表示当前jsp文件的配置信息，通常jsp无需配置，所以该对象不常使用。但是在Servlet种用处较大，因为Servlet需要在web.xml文件中进行配置，可以用来指定配置参数 getServletName()返回jsp对用的Servlet的名字，所有jsp的名字都相同，为jsp getInitParameter(String paramName)方法用于获取jsp的配置参数，jsp参数在web.xml文件中配置格式如下 123456789101112&lt;servlet&gt; &lt;servlet-name&gt;Servlet名称&lt;/servlet-name&gt; &lt;jsp-file&gt;jsp路径&lt;/jsp-file&gt; &lt;init-param&gt; &lt;param-name&gt;参数名1&lt;/param-name&gt; &lt;param-value&gt;参数值1&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;参数名2&lt;/param-name&gt; &lt;param-value&gt;参数值2&lt;/param-value&gt; &lt;/init-param&gt;&lt;/servlet&gt; ​ exceptionexception对象是Throwable的实例，代表jsp脚本中产生的错误和异常，是jsp页面异常机制的一部分，该对象仅在异常处理页面才有效 outout对象代表一个页面输出流，通常用于在页面上输出变量值以及常量 使用out的地方，都可以使用表达式&lt;% %&gt;来代替，显得更加简洁，表达式&lt;% %&gt;的本质就是out.write(…) page代表页面本身 pageContext该对象代表页面上下文，主要用于访问jsp之间的共享数据。使用pageContext可以访问page、request、response、application访问的变量 requestresponsesession","tags":[{"name":"web","slug":"web","permalink":"https://songjin1994.github.io/tags/web/"}]},{"title":"Linux下配置JavaWeb运行环境问题总结","date":"2016-11-01T03:04:38.000Z","path":"2016/11/01/Linux下配置JavaWeb问题总结/","text":"Linux下配置JavaWeb问题总结配置Apache HTTP服务器安装和配置使用系统：debian8.3 直接使用aptitude命令安装 1aptitude install apache2 启动、停止、重启相关命令 12 配置二级域名有时候需要创建二级域名并绑定到新的网站上，此时就需要在云解析上配置二级域名并映射到主机ip地址上，然后通过apache服务器对域名进行解析并转到相应的站点上。 步骤如下 建立二级域名A记录 你的域名解析服务器上添加一条”*”的A记录，主机记录（即子域名）为子域名称，例如填入abc，则二级域名为abc.主域名.com，并把域名映射到主机上 创建site配置文件 在/etc/apache2/sites-available目录下建一个新的site文件后缀名为.conf才能被apache识别，添加如下内容 12345&lt;VirtualHost *:80&gt; ServerAdmin mailName@gmail.com ServerName abc.cqsong.cn &lt;!-- 填入二级域名 --&gt; DocumentRoot /var/www/html/ &lt;!-- 网站根目录 --&gt;&lt;/VirtualHost&gt; 激活site文件，使用a2ensite命令激活 1a2ensite abc.conf //后为文件名 执行reload操作，使配置文件生效 12service apache2 reloadservice apache2 restart 在虚拟机中模拟路由可以使用修改hosts文件来实现域名和主机ip地址映射。 莫名其妙的中文路径乱码问题经过排查，是从windows中拷贝到Linux环境时，文件夹名和文件名的编码问题引起的，在windows中，中文默认编码使用的是GBK编码，而在Linux中，使用的是UTF-8编码。所以在文件拷贝之后，实际上在Linux中是乱码的形式，需要对文件夹名和文件名进行转码。使用的方式是convmv命令方式。 通过aptitude命令下载 1aptitude install convmv aptitude使用方式如下： 1convmv -f 源编码 -t 新编码 [选项] 文件名 常用参数： -r 递归处理子文件夹 –notest 真正进行操作，请注意在默认情况下是不对文件进行真实操作的，而只是试验。 –list 显示所有支持的编码 –unescap 可以做一下转义，比如把%20变成空格 修改windows到Linux文件名乱码命令如下： 1convmv -r -f gbk -t en_US.utf-8 --notest --nosmart html/ Tomcat相关tomcat启动延迟甚至卡住 找到jdk1.x.x_xx/jre/lib/security/Java.security文件，在文件中找到securerandom.source这个设置项，将其改为： securerandom.source=file:/dev/./urandom linux或者部分unix系统提供随机数设备是/dev/random 和/dev/urandom ，两个有区别，urandom安全性没有random高，但random需要时间间隔生成随机数。jdk默认调用random。 Java相关Java环境变量的问题编辑/etc/profile文件，在最后添加如下代码： 123export JAVA_HOME=/usr/song/java8export PATH=$JAVA_HOME/bin:$JAVA_HOME/jre/bin:$PATHexport CLASSPATH=$CLASSPATH:.:$JAVA_HOME/lib:$JAVA_HOME/jre/lib 保存退出，执行如下命令使环境变量立即生效 1source /etc/profile Nginx相关安装Nginx使用apt-get命令直接安装 1apt-get install nginx 配置文件说明主配置文件为/etc/nginx/nginx.conf，一般不作修改，对于配置反向代理和配置HTTP服务器只需要编辑/etc/nginx/sites-available/default文件即可，文件详情如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104### You should look at the following URL's in order to grasp a solid understanding# of Nginx configuration files in order to fully unleash the power of Nginx.# http://wiki.nginx.org/Pitfalls# http://wiki.nginx.org/QuickStart# http://wiki.nginx.org/Configuration## Generally, you will want to move this file somewhere, and start with a clean# file but keep this around for reference. Or just disable in sites-enabled.## Please see /usr/share/doc/nginx-doc/examples/ for more detailed examples.### Default server configuration#server &#123; listen 80 default_server; listen [::]:80 default_server; # SSL configuration # # listen 443 ssl default_server; # listen [::]:443 ssl default_server; # # Self signed certs generated by the ssl-cert package # Don't use them in a production server! # # include snippets/snakeoil.conf; root /var/www/html; # Add index.php to the list if you are using PHP index index.html index.htm index.nginx-debian.html; server_name _; location / &#123; # First attempt to serve request as file, then # as directory, then fall back to displaying a 404. try_files $uri $uri/ =404; &#125; # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \\.php$ &#123; # include snippets/fastcgi-php.conf; # # # With php5-cgi alone: # fastcgi_pass 127.0.0.1:9000; # # With php5-fpm: # fastcgi_pass unix:/var/run/php5-fpm.sock; #&#125; # deny access to .htaccess files, if Apache's document root # concurs with nginx's one # #location ~ /\\.ht &#123; # deny all; #&#125;&#125;# Virtual Host configuration for example.com## You can move that to a different file under sites-available/ and symlink that# to sites-enabled/ to enable it.##server &#123;# listen 80;# listen [::]:80;## server_name example.com;## root /var/www/example.com;# index index.html;## location / &#123;# try_files $uri $uri/ =404;# &#125;#&#125;# 配置二级域名，用于博客搭建server&#123; listen 80; server_name blog.cqsongjin.cn; index index.jsp index.html; root /var/www/html/blog/;&#125;# 配置二级域名，并整合tomcat实现反向代理server&#123; listen 80; server_name projects.cqsongjin.cn; index index.jsp index.html;location / &#123; add_header 'Access-Control-Allow-Origin' '*'; add_header 'Access-Control-Allow-Credentials' 'true'; add_header 'Access-Control-Allow-Methods' 'GET,POST'; index index.jsp; proxy_pass http://projects.cqsongjin.cn:8080; # proxy_set_header X-Real-IP $remote_addr; # proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;&#125;&#125; Nginx实现动静态资源分离Ajax相关Ajax跨域请求问题添加头文件方式解决123resp.setHeader(\"Access-Control-Allow-Origin\", \"*\");resp.setHeader(\"Access-Control-Allow-Credentials\" ,\"true\");resp.setHeader(\"Access-Control-Allow-Methods\",\"GET,POST\");","tags":[{"name":"Linux","slug":"Linux","permalink":"https://songjin1994.github.io/tags/Linux/"}]},{"title":"docker简单使用","date":"2016-10-23T12:58:28.000Z","path":"2016/10/23/docker简单使用/","text":"docker简单使用docker安装apt-get方式安装1apt-get install docker rpm方式安装1yum install docker-io 使用Daocloud镜像站安装新版docker1curl -sSL https://get.daocloud.io/docker | sh","tags":[{"name":"docker","slug":"docker","permalink":"https://songjin1994.github.io/tags/docker/"}]},{"title":"Spring之AOP","date":"2016-10-19T03:59:36.000Z","path":"2016/10/19/Spring之AOP/","text":"Spring之AOPAOP基础——面向切面编程简而言之，AOP面向切面编程的目的就是保证程序员在不修改源代码的情况下，为系统中业务组件的多个业务方法添加某种通过的过程（但其实底层实现仍然是修改了源代码，只是由AOP框架完成，无需手动实现）。 AOP 的实现方法大致分为两类 静态AOP代理：在代码编译时期对程序进行修改，实现对目标类的增强，生成静态的AOP代理类。例如AspectJ。 动态AOP代理：AOP框架在运行阶段动态生成AOP代理（有JDK动态代理和cglib动态生成代理两种方式），以实现对目标的增强。例如SpringAOP。 AOP的基本概念 切面（Aspect）：切面是通知和切点的集合，通知和切点共同定义了切面的全部内容（在何处何时完成何种功能） 通知（Advice）：切面中所定义的通知定义了切面需要实现的功能以及何时使用该功能。Spring定义了以下5种类型的通知 前置通知（Before）：在目标方法调用之前执行 后置通知（After）：在目标方法完成之后执行，此时无需关注方法的输出 返回通知（After-returning）：在目标方法成功执行之后执行 异常通知（After-throwing）：在目标方法抛出异常之后执行 环绕通知（Around）：在调用目标方法之前和调用之后执行自定义的行为 连接点（Join Point）：连接点是应用执行过程种能够插入切面的一个点，切面代码可以利用这些点插入到应用的正常流程种，并添加新的行为。这个连接点可以是调用方法时，抛出异常时，甚至修改一个字段时 切点（Pointcut）：切点匹配通知所要织入的一个或多个连接点，Advice定义了何时执行什么方法，切点就定义了何处执行这个方法 引入（Introduction）：引入使得我们可以向现有的类添加新方法和属性 织入（Weaving）：织入是把切面应用到目标对象并创建新的代理对象的过程，在目标对象的生命周期里有多个点可以进行织入 编译期：切面在目标类编译时被织入，此时需要特殊的编译器。 类加载器：切面在目标类加载到JVM时被织入。这种方式需要特殊的类加载器，他可以在目标类在引入应用前增强该目标类的字节码。Aspect5的加载时织入使用的就是这种方式 运行期：切面在运行时的某个时刻被织入。一般情况在，在织入切面时，AOP容器会为目标对象动态地创建一个代理对象。SpringAOP使用的就是这种方式进行织入 xml配置方式实现SpringAOPxml文件配置如下： beans.xml 1234567891011121314151617181920&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\"&gt; &lt;context:component-scan base-package=\"beans,aop\"/&gt; &lt;aop:aspectj-autoproxy proxy-target-class=\"true\"/&gt; &lt;aop:config&gt; &lt;aop:pointcut id=\"journalPoint\" expression=\"execution(* beans.teachers.*.*(int,String)) and args(num,str)\"/&gt; &lt;aop:aspect id=\"journalAspect\" ref=\"teacherJournal\"&gt; &lt;aop:before method=\"afterRun\" pointcut-ref=\"journalPoint\" arg-names=\"num,str\"/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt;&lt;/beans&gt; TeacherJournal.java 12345678910package aop;import org.springframework.stereotype.Component;@Componentpublic class TeacherJournal &#123; /*@After(\"execution(* beans.teachers.*.*(int,String)) &amp;&amp; args(num,str)\")*/ public void afterRun(int num,String str)&#123; System.out.println(\"after run!\"); System.out.println(\"num:\"+num+\"string:\"+str); &#125;&#125; 简单的切面配置如上，测试类省略 注解配置方式实现SpringAOPbeans.xml 1234567891011121314&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\"&gt; &lt;context:component-scan base-package=\"beans,aop\"/&gt; &lt;aop:aspectj-autoproxy proxy-target-class=\"true\"/&gt;&lt;/beans&gt; TeacherJournal.java 12345678910111213package aop;import org.aspectj.lang.annotation.After;import org.aspectj.lang.annotation.Aspect;import org.springframework.stereotype.Component;@Aspect@Componentpublic class TeacherJournal &#123; @After(\"execution(* beans.teachers.*.*(int,String)) &amp;&amp; args(num,str)\") public void afterRun(int num,String str)&#123; System.out.println(\"after run!\"); System.out.println(\"num:\"+num+\"string:\"+str); &#125;&#125; 注解方式无需在配置文件中配置大量复杂的属性，只需要通过简单的注解即可实现AOP 需要注意的是使用@Aspect和@After注解需要aspectjrt，aspectjweaver两个jar包的支持，因为Spring是借鉴了AspectJ的注解方法，但实现使用的依然是SpringAOP的实现方式 处理通知中的参数在以上两中配置方式的实例中，已经实现了通知参数的传递 在使用注解方式中，只需要在接收的方法中定义接收参数的类型，然后在表达式后加上&amp;&amp;args(参数名)的形式即可，参数名不需要非要和切点方法中的参数名保持一致 在使用xml配置方式中，实现的方法和注解方式基本一样，只是由于&amp;在xml中有其他含义，所以将&amp;&amp;替换为and语句即可","tags":[{"name":"Spring","slug":"Spring","permalink":"https://songjin1994.github.io/tags/Spring/"}]},{"title":"Spring之IOC","date":"2016-10-16T04:03:53.000Z","path":"2016/10/16/Spring之IOC/","text":"Spring之IOC使用JavaConfic方式进行配置Spring3.0之后的版本提供了一种通过java代码进行配置管理bean的新方法，简单例子如下： 12345678package conf;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;@Configuration@ComponentScan(basePackages = &#123;\"beans\",\"aop\"&#125;)public class JavaConfig &#123;&#125; 只需要通过一个@Configuration注解即可将一个普通的java类变成一个Spring配置类，@ComponentScan用于查找指定包下（包括子包）的所有使用注解注册的bean。 通常在一个javaConfic中，还有如下常用的注解： @Bean：用于修饰一个方法，将该方法的返回值注册为容器中的一个bean。bean的名称默认为方法名，也可以在注解中进行指定，例如@Bean(name = &quot;beanname&quot;) @Value：用于修饰一个Filed，并为该Filed配置一个值，例如@Value(&quot;fileValue&quot;) String fileValue @Import：修饰一个java配置类，用于向当前配置类中导入其他java配置类 @ImportResource：修饰一个java配置类，作用与上一个注解相似，但不是导入java配置类，而是导入xml配置文件 @Scope：修饰一个方法，指定该方法对应bean的生命域 @Lazy：用于修饰一个方法，指定该方法对应的bean是否需要延迟初始化，缺省值为true 使用如下@Lazy(false) @dependsOn：修饰一个方法，指定在初始化该方法对应bean之前先初始化指定的bean 使用xml方式进行配置使用xml方式配置管理bean有利于解耦，便于后期无法直接对源码直接进行修改时能够修改相关的配置 大致配置如下： 1234567&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;context:component-scan base-package=\"beans\"/&gt;&lt;/beans&gt; 个人比较懒，喜欢通过注解的方式配置bean，所以配置文件看起来就比较简洁，仅仅配置了一个bean扫描组件，作用与上文的@ComponentScan的作用一致 实现bean的自动装配bean的自动装配可以在xml配置文件中进行配置，但是非常不灵活，个人更倾向于使用注解的配置方式进行自动地装配，具体方式如下 @Resource注解方式（个人推荐）@Resource注解位于javax.annotation包下，是java EE的一个规范Annotation，所以我更倾向使用@Resource注解，适用范围更广泛，而且使用也比较简单，如下 1234@Resource(name = \"liStudent\") public void setStu1(Student stu1) &#123; this.stu1 = stu1; &#125; @Resource注解可以设置一个name属性，用于指定所需注入bean的名字，也可以不设置，则默认注入set方法所对应的属性名相同的bean @Resource不仅可以修饰setter方法，也可以直接修饰实例变量（使用java EE规范的Filed注入，不需要setter方法，也就是实现不需要反射机制） @Autowired注解方式（Spring提供）@Autowired可以修饰setter方法，普通方法，实例变量和构造器等 @Autowired默认采用byType自动装配策略，根据参数类型进行注入，如果恰好找到一个类型相同的bean，就直接注入，如果找到过个bean，则会报错，如果一个都没有找到，就什么都不执行，也不会报错org.springframework.beans.factory.NoUniqueBeanDefinitionException 有时候通过类型进行装配可能引发异常，则可以使用注解@Qualifier实现精准的自动装配实例如下 12345@Autowired @Qualifier(\"liStudent\") public void setStu1(Student stu1) &#123; this.stu1 = stu1; &#125; 当然，Spring也可以使用@Qualifier标注方法的形参进行装配 1234@Autowiredpublic void setStu1(@Qualifier(\"liStudent\") Student stu1) &#123; this.stu1 = stu1;&#125; @Inject注解方式（JSR-330标准）与@Autowired注解类似，默认采用byType方式进行注入，示例如下： 12345@Inject@Named(\"liStudent\")public void setStu1(Student stu1) &#123; this.stu1 = stu1;&#125;","tags":[{"name":"Spring","slug":"Spring","permalink":"https://songjin1994.github.io/tags/Spring/"}]},{"title":"","date":"2016-10-12T10:08:52.933Z","path":"2016/10/12/python基础/","text":"","tags":[]},{"title":"第一个python程序","date":"2016-10-12T10:00:34.000Z","path":"2016/10/12/FirstPython/","text":"第一个python程序准备阶段安装python相关环境 从命令行进入python交互模式在命令行下，执行python进入python交互模式 执行python语句在交互环境下，任意输入python语句，例如 11 + 1 可立即看到结果2 执行python脚本文件可以将python语句写在文本中，后缀名为py，例如新建一个py1.py文件，其内容为 1print(1 + 1) 在命令行执行如下命令（路径切换到其脚本文件所在目录） 1python py1.py 即可看到命令行打印出结果2 总结执行python代码可以通过输入python语句进入python交互模式直接输入代码执行，也可以通过python [文件名].py语句来执行python程序。","tags":[{"name":"python","slug":"python","permalink":"https://songjin1994.github.io/tags/python/"}]},{"title":"Spring之入门","date":"2016-10-10T07:05:40.000Z","path":"2016/10/10/Spring之入门/","text":"Spring之入门序言什么是Spring？简而言之，Spring是一个致力于全方位简化Java开发的轻量级框架，为了降低Java开发的复杂性，Spring主要从以下四个关键方向进行： 基于POJO的轻量级和最小侵入式编程 通过依赖注入和面向接口实现松耦合 基于切面和惯例进行声明式编程 通过切面和模板减少样板代码 Spring框架专注于通过依赖注入（DI，dependency injection），面向切面编程（AOP，aspect-oriented programming）和消除样板代码来简化Java开发，以下对这几种特性作简要总结，后续会详细进行讲解。 基本概念依赖注入（DI）一个常用的应用不会只由一个类独立完成，往往是由多个类来共同完成的。每个对象负责管理与自己相互协作（也就是相互依赖）的对象的引用，这将产生高耦合的代码，在一个庞大的项目中，大量的高耦合代码是不容易进行管理和调试的。 通过DI，对象的依赖关系将由Spring容器在创建对象的时候进行设定。对象无需自行创建或管理他们的依赖关系，将由容器根据预定的配置将所依赖的对象注入到相应的对象中。 面向切面编程（AOP）一个系统往往由许多不同功能的组件组成，每个组件除了各自的特定功能之外，还需要一些其他的额外功能，例如日志、事务管理和安全验证等等，这一类系统服务会跨越系统的多个组件中，通常被称为横切关注点。试想一下，如果各自功能组件分别实现自己的日志事务管理等功能，将会导致大量的重复代码，当需求改变时，需要对所有的代码进行修改，工作量也是巨大的。 AOP的功能在于使这一类服务模块化，并已声明的方式将他们应用到需要这些功能的组件中，而这些组件只需要完成自己功能的实现无需关注其他的功能。 Spring容器在Spring中，所有的应用对象都在Spring容器中。Spring容器负责创建对象，装配对象，配置对象并管理他们的整个生命周期。Spring容器使Spring框架的核心，它使用DI管理构成应用的组件，创建相互协作的组件之间的关联。","tags":[{"name":"Spring","slug":"Spring","permalink":"https://songjin1994.github.io/tags/Spring/"},{"name":"Java","slug":"Java","permalink":"https://songjin1994.github.io/tags/Java/"},{"name":"框架","slug":"框架","permalink":"https://songjin1994.github.io/tags/框架/"}]},{"title":"数据结构与算法常见问题总结","date":"2016-10-09T07:05:40.000Z","path":"2016/10/09/数据结构与算法常见问题总结/","text":"数据结构与算法常见问题总结输入一个整数，返回其反序整数12345678public static int Rev(int n)&#123; String str = \"\"+n; String tmp = \"\"; for(int i=0;i&lt;str.length();i++)&#123; tmp = tmp + str.charAt(str.length()-i-1); &#125; return Integer.parseInt(tmp);&#125; 利用栈实现回文验证，例如验证（）{}【】括号使用的合法性1234567891011121314151617181920public boolean isMatch(String args)&#123; String str = args; char temp = ' '; boolean flag = true; Stack&lt;Character&gt; stack = new Stack&lt;Character&gt;(); for (int i = 0;i&lt;str.length();i++)&#123; temp = str.charAt(i); if ('&#123;' == temp || '[' == temp || '(' == temp)&#123; stack.push(temp); &#125;else if ('&#125;' == temp &amp;&amp; '&#123;' != stack.pop())&#123; flag = false;break; &#125;else if (']' == temp &amp;&amp; '[' != stack.pop())&#123; flag = false;break; &#125;else if (')' == temp &amp;&amp; '(' != stack.pop())&#123; flag = false;break; &#125; &#125; if (! stack.empty())&#123;flag = false;&#125; return flag;&#125; ###输出一个集合的所有子集123456789101112131415161718192021222324public void childlist(int[] list)&#123; int num = 1 &lt;&lt;list.length; int p=0; int index = 0; for (int i = 0; i&lt;num-1; i++)&#123; p = i; index = 0; System.out.print(\"&#123;\"); while (p &gt; 0)&#123; if ((p &amp; 1) &gt;0)&#123; if ((p &gt;&gt; 1)&gt;0) &#123; System.out.print(list[index] + \",\"); &#125;else &#123; System.out.print(list[index]); &#125; &#125; p &gt;&gt;=1; index++; &#125; System.out.println(\"&#125;\"); &#125;&#125; 二分查找####使用循环实现二分查找1234567891011121314151617public int midSearch(int[] arrays,int key)&#123; int mid = arrays.length/2; if (key == arrays[mid])&#123;return mid;&#125; int start = 0; int end = arrays.length-1; while (start &lt;= end)&#123; mid = start + (end-start)/2; if (key &lt; arrays[mid])&#123; end = mid-1; &#125;else if (key &gt; arrays[mid])&#123; start = mid+1; &#125;else &#123; return mid; &#125; &#125; return -1;&#125; 使用递归实现二分查找1234567891011121314public int midSearch2(int[] arrays,int start,int end,int key)&#123; int mid = start + (end-start)/2; if (key == arrays[mid])&#123; return mid; &#125; if (start &gt;= end)&#123; return -1; &#125;else if (key &lt; arrays[mid])&#123; return midSearch2(arrays,start,mid-1,key); &#125;else if (key &gt; arrays[mid])&#123; return midSearch2(arrays,mid+1,end,key); &#125; return -1;&#125; 快速排序算法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152 /** * 重载方法一，对整个数组进行排序 * @param arrays */ public void quickSort(int[] arrays)&#123; if (arrays == null || arrays.length == 0)&#123; return; &#125; quickSort(arrays,0,arrays.length-1); &#125; /** * 重载方法二，对数组中指定区间进行排序 * @param arrays * @param left * @param right */ public void quickSort(int[] arrays,int left,int right)&#123; int mid = parttion(arrays,left,right); if (left &lt; right)&#123; quickSort(arrays,left,mid-1); quickSort(arrays,mid+1,right); &#125; &#125; /** * 分治算法，返回基准关键值的位置 * @param arrays * @param left * @param right * @return */ public int parttion(int[] arrays,int left,int right)&#123; int flag = arrays[left]; while (left &lt; right)&#123; while (arrays[right] &gt;= flag &amp;&amp; left &lt; right)&#123; right--; &#125; if (left &lt; right)&#123; arrays[left++] = arrays[right]; &#125; while (arrays[left] &lt;= flag &amp;&amp; left &lt;right)&#123; left++; &#125; if (left &lt; right)&#123; arrays[right--] = arrays[left]; &#125; &#125; arrays[left] = flag; return left; &#125;&#125; 返回一个杨辉三角的二维数组1234567891011121314151617/** * 返回一个杨辉三角 */public int[][] outYang(int n)&#123; int[][] yang = new int[n][]; for (int i =0;i&lt;n;i++)&#123; yang[i] = new int[i+1]; for (int j = 0;j&lt;=i;j++)&#123; if (j == 0 || j == i)&#123; yang[i][j] = 1; &#125;else if (i &gt; 0)&#123; yang[i][j] = yang[i-1][j-1] + yang[i-1][j]; &#125; &#125; &#125; return yang;&#125;","tags":[{"name":"Java","slug":"Java","permalink":"https://songjin1994.github.io/tags/Java/"},{"name":"算法","slug":"算法","permalink":"https://songjin1994.github.io/tags/算法/"}]},{"title":"JavaScript基础知识整理","date":"2016-09-11T16:00:00.000Z","path":"2016/09/12/JavaScript基础知识整理/","text":"JavaScript基础知识整理JavaScript对象 JavaScript对象——无序的集合数据类型，由若干键值对组成。 访问对象内部属性有两种方法，object.prop和obje[‘prop’]，其中后者主要用于属性不是一个有效的变量的情况。 在JavaScript中，访问对象中不存在的属性不会报错，而会返回undefined。 删除属性操作 delete object.prop。 检测某一属性是否存在 prop in object，其中继承所得到的属性也包括在其中。 判断一个属性是否为自身拥有而非继承所得到用hasOwnProperty(),object.hasOwnProperty(‘prop’)。 条件判断if{}…else{}注意：满足if条件后，就会执行if内的代码，执行后不会再判断else部分的条件是否满足 ##循环","tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://songjin1994.github.io/tags/Javascript/"}]},{"title":"java算法基础之常用排序算法","date":"2016-08-19T16:00:00.000Z","path":"2016/08/20/java算法基础之常用排序算法/","text":"java算法基础之常用排序算法1.冒泡排序冒泡排序算法的基本思路为：依次比较相邻两数，如果两数的顺序错误，就交换两个数的位置，直到比较完所有的数，则排序完成，java实现的代码如下所示： public static void bubbleSort(int[] array){ for (int i = array.length-1;i &gt;0;i--){ for (int j = 0;j &lt; i;j++){ if (array[j] &gt;array[j+1]){ int tmp; tmp = array[j]; array[j] = array[j+1]; array[j+1] = tmp; } } } } 算法提示：在交换位置之前加入的布尔类型的变量exchangeflag作为标志位，如果在一轮比较中没有发生交换，则说明排序完成，无需继续进行循环。 时间复杂度问题 冒泡排序算法最好的时间复杂度是O(n) 冒泡排序算法最坏的时间复杂度是O(n^2) 冒泡算法的平均时间复杂度是O(n^2) 2.选择排序算法选择排序算法的基本思路为：从被排序数组中找出最小的一个数放在数组的第一位，接着从剩下的数中选出最小的放在第二位，如此反复，直到排到第N-1位，排序结束 算法如下： public static void selectSort(int[] array){ for (int i = 0;i &lt; array.length-1;i++){ for (int j = i+1;j &lt; array.length;j++){ if (array[i] &lt;array[j]){ int tmp; tmp = array[i]; array[i] = array[j]; array[j] = tmp; } } } } 3.插入排序算法插入排序算法的基本思路为：选择第一位数为已排序数，取出下一位未排序的数，从后往前扫描，如果被扫描的数大于该未排序数，则两数交换位置，然后接着扫描，直到找到已排序的数小于或等于该未排序数，则将该新元素插入到这个位置。接着取出下一位未排序数，重复以上操作，知道所有数完成排序。 算法如下： public static void insertSort(int [] array){ int temp; for (int i =1;i &lt; array.length;i++){ for (int j = i;j &gt;0;j--){ if (array[j] &lt; array[j-1]){ temp = array[j]; array[j] = array[j-1]; array[j-1] = temp; }else { break; } } } }","tags":[{"name":"算法","slug":"算法","permalink":"https://songjin1994.github.io/tags/算法/"},{"name":"排序","slug":"排序","permalink":"https://songjin1994.github.io/tags/排序/"}]},{"title":"hibernate学习相关总结和问题解决","date":"2016-08-06T16:00:00.000Z","path":"2016/08/07/hibernate学习相关总结和问题解决/","text":"hibernate学习相关总结和问题解决常见问题hibernate不自动建表问题配置了&lt;property name=&quot;hibernate.hbm2ddl.auto&quot;&gt;update&lt;/property&gt;之后，在数据库中不存在相应的数据表的时候，仍然无法自动创建表，可以查看是否是数据库方言的问题， 出错原因：原代码 &lt;property name=&quot;hibernate.dialect&quot;&gt;org.hibernate.dialect.MySQLInnoDBDialect&lt;/property&gt;在mysql5.5以上版本，配置方言的时候mysql默认存储引擎为InnoDB，需创建新表（表名不存在），数据库方言只能选择MySQLDialect； 修改方案：修改配置为&lt;property name=&quot;dialect&quot;&gt;org.hibernate.dialect.MySQL5InnoDBDialect&lt;/property&gt;（推荐） 或者&lt;property name=&quot;hibernate.dialect&quot;&gt;org.hibernate.dialect.MySQDialect&lt;/property&gt; 配置文件模板记录&lt;?xml version=&apos;1.0&apos; encoding=&apos;utf-8&apos;?&gt; &lt;!DOCTYPE hibernate-configuration PUBLIC &quot;-//Hibernate/Hibernate Configuration DTD 3.0//EN&quot; &quot;http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd&quot;&gt; &lt;hibernate-configuration&gt; &lt;session-factory&gt; &lt;!-- Database connection settings --&gt; &lt;property name=&quot;connection.driver_class&quot;&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name=&quot;connection.url&quot;&gt;jdbc:mysql://localhost:3306/baron&lt;/property&gt; &lt;property name=&quot;connection.username&quot;&gt;root&lt;/property&gt; &lt;property name=&quot;connection.password&quot;&gt;songjin&lt;/property&gt; &lt;!-- JDBC connection pool (use the built-in) --&gt; &lt;property name=&quot;connection.pool_size&quot;&gt;1&lt;/property&gt; &lt;!-- SQL dialect --&gt; &lt;property name=&quot;dialect&quot;&gt;org.hibernate.dialect.MySQL5InnoDBDialect&lt;/property&gt; &lt;!-- Enable Hibernate&apos;s automatic session context management --&gt; &lt;property name=&quot;current_session_context_class&quot;&gt;thread&lt;/property&gt; &lt;!-- Disable the second-level cache --&gt; &lt;!-- &lt;property name=&quot;cache.provider_class&quot;&gt;org.hibernate.cache.internal.NoCacheProvider&lt;/property&gt; --&gt; &lt;!-- Echo all executed SQL to stdout --&gt; &lt;property name=&quot;show_sql&quot;&gt;true&lt;/property&gt; &lt;!-- Drop and re-create the database schema on startup --&gt; &lt;property name=&quot;hbm2ddl.auto&quot;&gt;update&lt;/property&gt; &lt;property name=&quot;hibernate.format_sql&quot;&gt;true&lt;/property&gt; &lt;!-- &lt;mapping resource=&quot;org/hibernate/tutorial/domain/Event.hbm.xml&quot;/&gt; --&gt; &lt;mapping resource=&quot;com/song/hb/model/user.hbm.xml&quot;/&gt; &lt;mapping class=&quot;com.song.hb.model.Teacher&quot;/&gt; &lt;/session-factory&gt; &lt;/hibernate-configuration&gt; hibernate4获取SessionFactory的方式变化Configuration configuration = new Configuration().configure(); StandardServiceRegistry serviceRegistry = new StandardServiceRegistryBuilder().applySettings(configuration.getProperties()).build(); SessionFactory sessionFactory = configuration.buildSessionFactory(serviceRegistry); 简单配置上手1234567891011121314151617181920212223&lt;bean id=\"dataSource\" class=\"org.apache.commons.dbcp2.BasicDataSource\" destroy-method=\"close\" p:driverClassName=\"com.mysql.jdbc.Driver\" p:url=\"jdbc:mysql://localhost:3306/baron\" p:username=\"root\" p:password=\"songjin\" /&gt;&lt;bean id=\"sessionFactory\" class=\"org.springframework.orm.hibernate4.LocalSessionFactoryBean\" p:dataSource-ref=\"dataSource\" p:packagesToScan=\"model\"&gt; &lt;property name=\"hibernateProperties\"&gt; &lt;value&gt; hibernate.dialect=org.hibernate.dialect.MySQL5InnoDBDialect hibernate.show_sql=true hbm2ddl.auto=update hibernate.format_sql=true hibernate.connection.autocommit=true &lt;/value&gt; &lt;/property&gt;&lt;/bean&gt;&lt;bean id=\"txManager\" class=\"org.springframework.orm.hibernate4.HibernateTransactionManager\" p:sessionFactory-ref=\"sessionFactory\"/&gt;&lt;bean id=\"jdbcTemplate\" class=\"org.springframework.jdbc.core.JdbcTemplate\" c:dataSource-ref=\"dataSource\"/&gt;&lt;tx:annotation-driven transaction-manager=\"txManager\"/&gt; 与Spring整合相关问题简单整合问题事务管理在测试方法中自动回滚","tags":[{"name":"Java","slug":"Java","permalink":"https://songjin1994.github.io/tags/Java/"},{"name":"框架","slug":"框架","permalink":"https://songjin1994.github.io/tags/框架/"},{"name":"ORM","slug":"ORM","permalink":"https://songjin1994.github.io/tags/ORM/"}]},{"title":"Spring之MVC","date":"2016-06-24T16:00:00.000Z","path":"2016/06/25/Spring之MVC/","text":"Spring之MVC前言：近期从学习s2sh框架转到SpringMVC，写下此随笔记录学习中的问题和总结，方便日后进行查阅 SpringMVC框架特点相比较Struts2来说，SpringMVC是一个轻量级的MVC框架。之所以说轻量级，是因为Struts2是基于类级别的拦截，针对每一个请求，都需要一个对应的Action来进行处理，而SpringMVC是基于方法级别的拦截，开发效率和执行效率要高于Struts2. SpringMVC的核心是一个DispatcherServlet类。与大多数javaWeb框架一样，SpringMVC所有的请求都会通过一个前端控制器Servlet，也就是DispatcherServlet DispatcherServlet的任务就是将请求发送给SpringMVC控制器，即一个Controller。控制器是一个用于处理请求的Spring组件。 通过以上内容，对SpringMVC有了一个大概的了解，接下里将进行一个简单的SpringMVC框架的配置。 配置SpringMVC补充：Servlet3.0新特性： 异步处理支持：有了该特性，Servlet 线程不再需要一直阻塞，直到业务处理完毕才能再输出响应，最后才结束该 Servlet 线程。在接收到请求之后，Servlet 线程可以将耗时的操作委派给另一个线程来完成，自己在不生成响应的情况下返回至容器。针对业务处理较耗时的情况，这将大大减少服务器资源的占用，并且提高并发处理速度。 新增的注解支持：该版本新增了若干注解，用于简化 Servlet、过滤器（Filter）和监听器（Listener）的声明，这使得 web.xml 部署描述文件从该版本开始不再是必选的了。 可插性支持：熟悉 Struts2 的开发者一定会对其通过插件的方式与包括 Spring 在内的各种常用框架的整合特性记忆犹新。将相应的插件封装成 JAR 包并放在类路径下，Struts2 运行时便能自动加载这些插件。现在 Servlet 3.0 提供了类似的特性，开发者可以通过插件的方式很方便的扩充已有 Web 应用的功能，而不需要修改原有的应用。 传统的Servlet配置方式是采用web.xml文件进行配置。但是在Servlet3的新规范中，并不推荐这种配置方式，而通过spring3.1之后的功能增强和Servlet3的新规范，可以使用一种更便捷的新方法，通过java类的方式来配置DispatcherServlet 使用JavaConfig方式配置首先，需要新建一个类，继承AbstractAnnotationConfigDispatcherServletInitializer类，我将这个类命名为MyWebAppInitializer MyWebAppInitializer.java123456789101112131415161718192021222324252627282930313233343536373839404142package com.song.web.config;import org.springframework.web.servlet.support.AbstractAnnotationConfigDispatcherServletInitializer;import javax.servlet.Filter;import javax.servlet.MultipartConfigElement;import javax.servlet.ServletRegistration;public class MyWebAppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer &#123; @Override protected Class&lt;?&gt;[] getRootConfigClasses() &#123; return new Class&lt;?&gt;[] &#123;RootConfig.class&#125;; &#125; @Override protected Class&lt;?&gt;[] getServletConfigClasses() &#123; return new Class&lt;?&gt;[] &#123;WebConfig.class&#125;; &#125; @Override protected String[] getServletMappings() &#123; return new String[] &#123;\"/\"&#125;; &#125; /** * 可用此方法配置Filter * @return */ @Override protected Filter[] getServletFilters() &#123; return new Filter[] &#123;&#125;; &#125; /** * 上传文件参数配置 * @param registration */ @Override protected void customizeRegistration(ServletRegistration.Dynamic registration) &#123; registration.setMultipartConfig( new MultipartConfigElement(\"d:/tmp/\",419430400,419430400,0) ); &#125;&#125; 下面对这个类进行说明，为什么要创建一个这样的类？在Servlet3.0的环境中，容器会在类路径中查找实现了javax.servlet.ServletContainerInitializer接口的类，如果找到了这个类，就用它来配置Servlet容器。幸运的是，Spring已经提供了这个接口的实现，那就是SpringServletContainerInitializer这个类，这个类又会反过来查找实现了WebApplicationInitializer接口的类，并将非陪的任务交给他们完成。Spring3.2之后提供了一个便利的实现，那就是AbstractAnnotationConfigDispatcherServletInitializer这个类，由于MyWebAppInitializer继承了这个类，也就同时实现了WebApplicationInitializer这个接口，所以当部署到Servlet3.0容器中的时候，容器就会自动发现它，并用来配置Servlet上下文。通过其中的方法，即可完成对DispatcherServlet的配置 下面对类中的方法进行说明 getRootConfigClasses()：返回一个Spring配置类数组，用来配置其他工具bean类，例如DataSource，Mybatis，Service类等等。 getServletConfigClasses()：返回一个springMVC配置类数组，用来配置与web相关的bean类，例如controller类等等。 AbstractAnnotationConfigDispatcherServletInitializer在初始化的时候，会自动帮我们注册DispatcherServlet类，并根据getServletConfigClasses（）提供的配置类创建servletContext，但在SpringWeb应用中，一般还会有另一个ApplicationContext，是由ContextLoaderListener创建的，其中ApplicationContext是ServletContext的父容器，也就是说ServletContext可以访问ApplicationContext中声明的bean。 除了以上简单配置外，另外springMVC所需要的各种过滤器并没有在其中进行配置，感觉这样配置的话会显得很杂乱，所以我个人是将这些过滤器在wwb.xml中进行配置，如编码过滤器配置如下：12345678910111213141516&lt;filter&gt;&lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;&lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;&lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt;&lt;/init-param&gt;&lt;init-param&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt;&lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt;&lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;&lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 其中RootConfig.java代码如下：12345678910111213141516171819202122package com.song.web.config;import org.springframework.context.annotation.*;import org.springframework.web.servlet.config.annotation.EnableWebMvc;/** * 声明为配置类，用于配置Spring容器 */@Configuration/** * 导入其他配置文件，当只能通过mxl配置某些组件的时候可以考虑这种方式，此处用于引入Spring组件的相关配置 */@ImportResource(\"classpath:xml/spring-mybatis.xml\")/** * 配置组件扫描，自动扫描相关包下使用@Component、@Controller、@Service等注解的类，将其配置为bean组件 */@ComponentScan(basePackages =&#123;\"com.song\"&#125;, excludeFilters = &#123;@ComponentScan.Filter(type = FilterType.ANNOTATION,value = EnableWebMvc.class)&#125;)public class RootConfig &#123; &#125; WebConfig.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.song.web.config;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;import org.springframework.web.multipart.MultipartResolver;import org.springframework.web.multipart.support.StandardServletMultipartResolver;import org.springframework.web.servlet.ViewResolver;import org.springframework.web.servlet.config.annotation.DefaultServletHandlerConfigurer;import org.springframework.web.servlet.config.annotation.EnableWebMvc;import org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;import org.springframework.web.servlet.view.InternalResourceViewResolver;@Configuration/*** * 启用SpringMvc的支持 */@EnableWebMvc@ComponentScan(\"com.song,web\")public class WebConfig extends WebMvcConfigurerAdapter&#123; /** * 注册一个简单的视图解析器 * @return */ @Bean public ViewResolver viewResolver()&#123; InternalResourceViewResolver resolver = new InternalResourceViewResolver(); resolver.setPrefix(\"/WEB-INF/views/\"); resolver.setSuffix(\".jsp\"); resolver.setExposeContextBeansAsAttributes(true); return resolver; &#125; /** * 用于上传操作的组件 * @return */ @Bean public MultipartResolver multipartResolver()&#123; return new StandardServletMultipartResolver(); &#125; /** * 配置静态资源的处理，将静态资源的请求转发到Servlet容器中默认的Servlet上 * @param configurer */ @Override public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) &#123; configurer.enable(); &#125;&#125; 以上便完成了一个简单的SpringMVC框架配置 使用传统xml方式配置web.xml文件如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd\" version=\"3.1\"&gt; &lt;!--默认的首页--&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;welcome-file&gt;default.html&lt;/welcome-file&gt; &lt;welcome-file&gt;default.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;default.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;!-- 如果是用maven命令生成的xml，需要修改servlet版本为3.1 --&gt; &lt;!-- 配置DispatcherServlet --&gt; &lt;!-- 配置根上下文环境--&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring/spring-*.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;servlet&gt; &lt;display-name&gt;CloudDisk&lt;/display-name&gt; &lt;!-- 项目名称 --&gt; &lt;servlet-name&gt;mvc-dispatcher&lt;/servlet-name&gt; &lt;!-- mvc调度器 --&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 配置springMVC需要加载的配置文件 spring-dao.xml.xml,spring-service.xml,spring-web.xml Mybatis - &gt; spring -&gt; springmvc --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring/servlet-mvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;multipart-config&gt; &lt;location&gt;d:/tmp&lt;/location&gt; &lt;/multipart-config&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;mvc-dispatcher&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!-- 解决中文乱码问题--&gt; &lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt; servlet-mvc.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:jee=\"http://www.springframework.org/schema/jee\" xmlns:util=\"http://www.springframework.org/schema/util\" xmlns:p=\"http://www.springframework.org/schema/p\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xmlns:task=\"http://www.springframework.org/schema/task\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsdhttp://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsdhttp://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsdhttp://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsdhttp://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsdhttp://www.springframework.org/schema/jee http://www.springframework.org/schema/jee/spring-jee.xsdhttp://www.springframework.org/schema/taskhttp://www.springframework.org/schema/task/spring-task.xsdhttp://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd\"&gt; &lt;mvc:annotation-driven/&gt; &lt;context:component-scan base-package=\"com.song.web\"/&gt; &lt;!-- 配置静态资源访问--&gt; &lt;mvc:default-servlet-handler /&gt; &lt;bean id=\"viewResolver\" class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\" p:prefix=\"/WEB-INF/views/\" p:suffix=\".jsp\" p:exposeContextBeansAsAttributes=\"true\"&gt; &lt;/bean&gt; &lt;bean id=\"fmViewResolver\" class=\"org.springframework.web.servlet.view.freemarker.FreeMarkerViewResolver\" p:prefix=\"/one/\" p:suffix=\".ftl\" p:contentType=\"utf-8\" p:order=\"0\"/&gt; &lt;bean id=\"fmViewConfig\" class=\"org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer\" p:templateLoaderPath=\"/WEB-INF/fmtemplate/\" p:defaultEncoding=\"utf-8\" &gt; &lt;property name=\"freemarkerSettings\"&gt; &lt;props&gt; &lt;prop key=\"template_update_delay\"&gt;1&lt;/prop&gt; &lt;prop key=\"locale\"&gt;zh_CN&lt;/prop&gt; &lt;prop key=\"datetime_format\"&gt;yyyy-MM-dd HH:mm:ss&lt;/prop&gt; &lt;prop key=\"date_format\"&gt;yyyy-MM-dd&lt;/prop&gt; &lt;prop key=\"number_format\"&gt;#.##&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean id=\"multipartResolver\" class=\"org.springframework.web.multipart.support.StandardServletMultipartResolver\"&gt; &lt;/bean&gt;&lt;/beans&gt; spring-root.xml 1234567&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;context:component-scan base-package=\"com.song\"/&gt;&lt;/beans&gt; SpringMVC高级配置视图解析器文件上传跨重定向请求传递数据问题总结： mybatis设置了主键自增之后为什么仍然报错，显示主键为空？原因是mybatis的主键自增需要是基于数据库的主键自增，所以在数据库里面一定要启动主键的自增选项，这样才会生效。 ​","tags":[{"name":"Java","slug":"Java","permalink":"https://songjin1994.github.io/tags/Java/"},{"name":"框架","slug":"框架","permalink":"https://songjin1994.github.io/tags/框架/"}]},{"title":"Struts2配置文件相关标签及其属性","date":"2016-05-09T16:00:00.000Z","path":"2016/05/10/Struts2配置文件相关标签及其属性/","text":"Struts2配置文件相关标签及其属性constantpackage:用法和java的包类似，用于区分同名的action name：包名 extends：继承的包名，一般默认为“struts-default” namespace：指定名称空间，也就是访问此包下的Action需要访问的路径 abstract：将包声明为抽象类型（即包中不包括action） action###action直接继承actionsupport类，主要实现execute（）方法路径访问先找filter，之后寻找struts配置文件中相应的namespace，如果无，法找到相应的namespace，则返回web.xml执行相应操作，如果找到了，则寻找对应的action，根据执行action后返回的String字符串，在result标签中找到对应的result视图执行 name：用于配置Action对象被请求的URL映射 class：指定Action对象的类名 method：设置请求Action对象时，调用Action对象的哪一个方法,通过method指定来实现方法调用会产生大量action实例，浪费资源，所以一般不推荐使用。一般使用动态方法调用DMI converter：指定Action对象类型转换器的类 result相关注意事项：","tags":[{"name":"Java","slug":"Java","permalink":"https://songjin1994.github.io/tags/Java/"},{"name":"框架","slug":"框架","permalink":"https://songjin1994.github.io/tags/框架/"}]},{"title":"JDBC进行数据库连接操作","date":"2016-02-12T16:00:00.000Z","path":"2016/02/13/webserve_数据库操作/","text":"JDBC进行数据库连接操作 在page指令中可以使用import导入所需要的java开发包java.sql，进行数据库开发。 查询代码如下所示 &lt;%@page contentType=&quot;text/html&quot; pageEncoding=&quot;GBK&quot; %&gt; &lt;%@page import=&quot;java.sql.*&quot; %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;jdbc编程测试&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;%! public static final String DBDRIVER=&quot;org.gjt.mm.mysql.Driver&quot;; public static final String DBURL=&quot;jdbc:mysql://localhost:3306/baron&quot;; public static final String DBUSER=&quot;root&quot;; public static final String DBPASS=&quot;mysql&quot;; %&gt; &lt;% Connection conn=null; PreparedStatement pstmt=null; ResultSet rs=null; %&gt; &lt;% try { Class.forName(DBDRIVER); conn=DriverManager.getConnection(DBURL,DBUSER,DBPASS); String sql=&quot;SELECT name,age FROM user&quot;; pstmt=conn.prepareStatement(sql); rs=pstmt.executeQuery(); while (rs.next()){ String name=rs.getString(&quot;name&quot;); int age=rs.getInt(&quot;age&quot;); %&gt; &lt;%=name%&gt;&lt;br&gt;&lt;%=age%&gt;&lt;br&gt; &lt;% } rs.close(); pstmt.close(); conn.close(); }catch (Exception e){ e.printStackTrace(); } %&gt; &lt;%=&quot;结果显示&quot;%&gt; &lt;/body&gt; &lt;/html&gt;","tags":[{"name":"web","slug":"web","permalink":"https://songjin1994.github.io/tags/web/"},{"name":"JDBC","slug":"JDBC","permalink":"https://songjin1994.github.io/tags/JDBC/"},{"name":"Javaweb","slug":"Javaweb","permalink":"https://songjin1994.github.io/tags/Javaweb/"}]}]