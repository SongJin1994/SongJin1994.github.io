[{"title":"Spring框架学习（入门篇）","date":"2016-10-10T07:05:40.000Z","path":"2016/10/10/Spring框架学习（入门篇）/","text":"初探Spring序言什么是Spring？简而言之，Spring是一个致力于全方位简化Java开发的轻量级框架，为了降低Java开发的复杂性，Spring主要从以下四个关键方向进行： 基于POJO的轻量级和最小侵入式编程 通过依赖注入和面向接口实现松耦合 基于切面和惯例进行声明式编程 通过切面和模板减少样板代码 Spring框架专注于通过依赖注入（DI，dependency injection），面向切面编程（AOP，aspect-oriented programming）和消除样板代码来简化Java开发，以下对这几种特性作简要总结，后续会详细进行讲解。 基本概念依赖注入（DI）一个常用的应用不会只由一个类独立完成，往往是由多个类来共同完成的。每个对象负责管理与自己相互协作（也就是相互依赖）的对象的引用，这将产生高耦合的代码，在一个庞大的项目中，大量的高耦合代码是不容易进行管理和调试的。 通过DI，对象的依赖关系将由Spring容器在创建对象的时候进行设定。对象无需自行创建或管理他们的依赖关系，将由容器根据预定的配置将所依赖的对象注入到相应的对象中。 面向切面编程（AOP）一个系统往往由许多不同功能的组件组成，每个组件除了各自的特定功能之外，还需要一些其他的额外功能，例如日志、事务管理和安全验证等等，这一类系统服务会跨越系统的多个组件中，通常被称为横切关注点。试想一下，如果各自功能组件分别实现自己的日志事务管理等功能，将会导致大量的重复代码，当需求改变时，需要对所有的代码进行修改，工作量也是巨大的。 AOP的功能在于使这一类服务模块化，并已声明的方式将他们应用到需要这些功能的组件中，而这些组件只需要完成自己功能的实现无需关注其他的功能。 Spring容器在Spring中，所有的应用对象都在Spring容器中。Spring容器负责创建对象，装配对象，配置对象并管理他们的整个生命周期。Spring容器使Spring框架的核心，它使用DI管理构成应用的组件，创建相互协作的组件之间的关联。","tags":[{"name":"框架","slug":"框架","permalink":"https://songjin1994.github.io/tags/框架/"},{"name":"java","slug":"java","permalink":"https://songjin1994.github.io/tags/java/"},{"name":"Spring","slug":"Spring","permalink":"https://songjin1994.github.io/tags/Spring/"}]},{"title":"数据结构与算法常见问题总结","date":"2016-10-09T07:05:40.000Z","path":"2016/10/09/数据结构与算法常见问题总结/","text":"数据结构与算法常见问题总结输入一个整数，返回其反序整数12345678public static int Rev(int n)&#123; String str = \"\"+n; String tmp = \"\"; for(int i=0;i&lt;str.length();i++)&#123; tmp = tmp + str.charAt(str.length()-i-1); &#125; return Integer.parseInt(tmp);&#125; 利用栈实现回文验证，例如验证（）{}【】括号使用的合法性1234567891011121314151617181920public boolean isMatch(String args)&#123; String str = args; char temp = ' '; boolean flag = true; Stack&lt;Character&gt; stack = new Stack&lt;Character&gt;(); for (int i = 0;i&lt;str.length();i++)&#123; temp = str.charAt(i); if ('&#123;' == temp || '[' == temp || '(' == temp)&#123; stack.push(temp); &#125;else if ('&#125;' == temp &amp;&amp; '&#123;' != stack.pop())&#123; flag = false;break; &#125;else if (']' == temp &amp;&amp; '[' != stack.pop())&#123; flag = false;break; &#125;else if (')' == temp &amp;&amp; '(' != stack.pop())&#123; flag = false;break; &#125; &#125; if (! stack.empty())&#123;flag = false;&#125; return flag;&#125; ###输出一个集合的所有子集123456789101112131415161718192021222324public void childlist(int[] list)&#123; int num = 1 &lt;&lt;list.length; int p=0; int index = 0; for (int i = 0; i&lt;num-1; i++)&#123; p = i; index = 0; System.out.print(\"&#123;\"); while (p &gt; 0)&#123; if ((p &amp; 1) &gt;0)&#123; if ((p &gt;&gt; 1)&gt;0) &#123; System.out.print(list[index] + \",\"); &#125;else &#123; System.out.print(list[index]); &#125; &#125; p &gt;&gt;=1; index++; &#125; System.out.println(\"&#125;\"); &#125;&#125; 二分查找####使用循环实现二分查找1234567891011121314151617public int midSearch(int[] arrays,int key)&#123; int mid = arrays.length/2; if (key == arrays[mid])&#123;return mid;&#125; int start = 0; int end = arrays.length-1; while (start &lt;= end)&#123; mid = start + (end-start)/2; if (key &lt; arrays[mid])&#123; end = mid-1; &#125;else if (key &gt; arrays[mid])&#123; start = mid+1; &#125;else &#123; return mid; &#125; &#125; return -1;&#125; 使用递归实现二分查找1234567891011121314public int midSearch2(int[] arrays,int start,int end,int key)&#123; int mid = start + (end-start)/2; if (key == arrays[mid])&#123; return mid; &#125; if (start &gt;= end)&#123; return -1; &#125;else if (key &lt; arrays[mid])&#123; return midSearch2(arrays,start,mid-1,key); &#125;else if (key &gt; arrays[mid])&#123; return midSearch2(arrays,mid+1,end,key); &#125; return -1;&#125; 快速排序算法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152 /** * 重载方法一，对整个数组进行排序 * @param arrays */ public void quickSort(int[] arrays)&#123; if (arrays == null || arrays.length == 0)&#123; return; &#125; quickSort(arrays,0,arrays.length-1); &#125; /** * 重载方法二，对数组中指定区间进行排序 * @param arrays * @param left * @param right */ public void quickSort(int[] arrays,int left,int right)&#123; int mid = parttion(arrays,left,right); if (left &lt; right)&#123; quickSort(arrays,left,mid-1); quickSort(arrays,mid+1,right); &#125; &#125; /** * 分治算法，返回基准关键值的位置 * @param arrays * @param left * @param right * @return */ public int parttion(int[] arrays,int left,int right)&#123; int flag = arrays[left]; while (left &lt; right)&#123; while (arrays[right] &gt;= flag &amp;&amp; left &lt; right)&#123; right--; &#125; if (left &lt; right)&#123; arrays[left++] = arrays[right]; &#125; while (arrays[left] &lt;= flag &amp;&amp; left &lt;right)&#123; left++; &#125; if (left &lt; right)&#123; arrays[right--] = arrays[left]; &#125; &#125; arrays[left] = flag; return left; &#125;&#125;","tags":[{"name":"算法","slug":"算法","permalink":"https://songjin1994.github.io/tags/算法/"},{"name":"java","slug":"java","permalink":"https://songjin1994.github.io/tags/java/"}]},{"title":"JavaScript基础知识整理","date":"2016-09-11T16:00:00.000Z","path":"2016/09/12/JavaScript基础知识整理/","text":"JavaScript基础知识整理JavaScript对象 JavaScript对象——无序的集合数据类型，由若干键值对组成。 访问对象内部属性有两种方法，object.prop和obje[‘prop’]，其中后者主要用于属性不是一个有效的变量的情况。 在JavaScript中，访问对象中不存在的属性不会报错，而会返回undefined。 删除属性操作 delete object.prop。 检测某一属性是否存在 prop in object，其中继承所得到的属性也包括在其中。 判断一个属性是否为自身拥有而非继承所得到用hasOwnProperty(),object.hasOwnProperty(‘prop’)。 条件判断if{}…else{}注意：满足if条件后，就会执行if内的代码，执行后不会再判断else部分的条件是否满足 ##循环","tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://songjin1994.github.io/tags/Javascript/"}]},{"title":"java算法基础之常用排序算法","date":"2016-08-19T16:00:00.000Z","path":"2016/08/20/java算法基础之常用排序算法/","text":"java算法基础之常用排序算法1.冒泡排序冒泡排序算法的基本思路为：依次比较相邻两数，如果两数的顺序错误，就交换两个数的位置，直到比较完所有的数，则排序完成，java实现的代码如下所示： public static void bubbleSort(int[] array){ for (int i = array.length-1;i &gt;0;i--){ for (int j = 0;j &lt; i;j++){ if (array[j] &gt;array[j+1]){ int tmp; tmp = array[j]; array[j] = array[j+1]; array[j+1] = tmp; } } } } 算法提示：在交换位置之前加入的布尔类型的变量exchangeflag作为标志位，如果在一轮比较中没有发生交换，则说明排序完成，无需继续进行循环。 时间复杂度问题 冒泡排序算法最好的时间复杂度是O(n) 冒泡排序算法最坏的时间复杂度是O(n^2) 冒泡算法的平均时间复杂度是O(n^2) 2.选择排序算法选择排序算法的基本思路为：从被排序数组中找出最小的一个数放在数组的第一位，接着从剩下的数中选出最小的放在第二位，如此反复，直到排到第N-1位，排序结束 算法如下： public static void selectSort(int[] array){ for (int i = 0;i &lt; array.length-1;i++){ for (int j = i+1;j &lt; array.length;j++){ if (array[i] &lt;array[j]){ int tmp; tmp = array[i]; array[i] = array[j]; array[j] = tmp; } } } } 3.插入排序算法插入排序算法的基本思路为：选择第一位数为已排序数，取出下一位未排序的数，从后往前扫描，如果被扫描的数大于该未排序数，则两数交换位置，然后接着扫描，直到找到已排序的数小于或等于该未排序数，则将该新元素插入到这个位置。接着取出下一位未排序数，重复以上操作，知道所有数完成排序。 算法如下： public static void insertSort(int [] array){ int temp; for (int i =1;i &lt; array.length;i++){ for (int j = i;j &gt;0;j--){ if (array[j] &lt; array[j-1]){ temp = array[j]; array[j] = array[j-1]; array[j-1] = temp; }else { break; } } } }","tags":[{"name":"算法","slug":"算法","permalink":"https://songjin1994.github.io/tags/算法/"},{"name":"排序","slug":"排序","permalink":"https://songjin1994.github.io/tags/排序/"}]},{"title":"hibernate学习相关总结和问题解决","date":"2016-08-06T16:00:00.000Z","path":"2016/08/07/hibernate学习相关总结和问题解决/","text":"hibernate学习相关总结和问题解决hibernate不自动建表问题配置了&lt;property name=&quot;hibernate.hbm2ddl.auto&quot;&gt;update&lt;/property&gt;之后，在数据库中不存在相应的数据表的时候，仍然无法自动创建表，可以查看是否是数据库方言的问题， 出错原因：原代码 &lt;property name=&quot;hibernate.dialect&quot;&gt;org.hibernate.dialect.MySQLInnoDBDialect&lt;/property&gt;在mysql5.5以上版本，配置方言的时候mysql默认存储引擎为InnoDB，需创建新表（表名不存在），数据库方言只能选择MySQLDialect； 修改方案：修改配置为&lt;property name=&quot;dialect&quot;&gt;org.hibernate.dialect.MySQL5InnoDBDialect&lt;/property&gt;（推荐） 或者&lt;property name=&quot;hibernate.dialect&quot;&gt;org.hibernate.dialect.MySQDialect&lt;/property&gt; 配置文件模板记录&lt;?xml version=&apos;1.0&apos; encoding=&apos;utf-8&apos;?&gt; &lt;!DOCTYPE hibernate-configuration PUBLIC &quot;-//Hibernate/Hibernate Configuration DTD 3.0//EN&quot; &quot;http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd&quot;&gt; &lt;hibernate-configuration&gt; &lt;session-factory&gt; &lt;!-- Database connection settings --&gt; &lt;property name=&quot;connection.driver_class&quot;&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name=&quot;connection.url&quot;&gt;jdbc:mysql://localhost:3306/baron&lt;/property&gt; &lt;property name=&quot;connection.username&quot;&gt;root&lt;/property&gt; &lt;property name=&quot;connection.password&quot;&gt;songjin&lt;/property&gt; &lt;!-- JDBC connection pool (use the built-in) --&gt; &lt;property name=&quot;connection.pool_size&quot;&gt;1&lt;/property&gt; &lt;!-- SQL dialect --&gt; &lt;property name=&quot;dialect&quot;&gt;org.hibernate.dialect.MySQL5InnoDBDialect&lt;/property&gt; &lt;!-- Enable Hibernate&apos;s automatic session context management --&gt; &lt;property name=&quot;current_session_context_class&quot;&gt;thread&lt;/property&gt; &lt;!-- Disable the second-level cache --&gt; &lt;!-- &lt;property name=&quot;cache.provider_class&quot;&gt;org.hibernate.cache.internal.NoCacheProvider&lt;/property&gt; --&gt; &lt;!-- Echo all executed SQL to stdout --&gt; &lt;property name=&quot;show_sql&quot;&gt;true&lt;/property&gt; &lt;!-- Drop and re-create the database schema on startup --&gt; &lt;property name=&quot;hbm2ddl.auto&quot;&gt;update&lt;/property&gt; &lt;property name=&quot;hibernate.format_sql&quot;&gt;true&lt;/property&gt; &lt;!-- &lt;mapping resource=&quot;org/hibernate/tutorial/domain/Event.hbm.xml&quot;/&gt; --&gt; &lt;mapping resource=&quot;com/song/hb/model/user.hbm.xml&quot;/&gt; &lt;mapping class=&quot;com.song.hb.model.Teacher&quot;/&gt; &lt;/session-factory&gt; &lt;/hibernate-configuration&gt; hibernate4获取SessionFactory的方式变化Configuration configuration = new Configuration().configure(); StandardServiceRegistry serviceRegistry = new StandardServiceRegistryBuilder().applySettings(configuration.getProperties()).build(); SessionFactory sessionFactory = configuration.buildSessionFactory(serviceRegistry);","tags":[{"name":"框架","slug":"框架","permalink":"https://songjin1994.github.io/tags/框架/"},{"name":"Java","slug":"Java","permalink":"https://songjin1994.github.io/tags/Java/"},{"name":"ORM","slug":"ORM","permalink":"https://songjin1994.github.io/tags/ORM/"}]},{"title":"SpringMVC学习相关总结","date":"2016-06-24T16:00:00.000Z","path":"2016/06/25/SpringMVC学习相关总结/","text":"SpringMVC学习相关总结前言：近期从学习s2sh框架转到SpringMVC，写下此随笔记录学习中的问题和总结，方便日后进行查阅 SpringMVC框架特点相比较Struts2来说，SpringMVC是一个轻量级的MVC框架。之所以说轻量级，是因为Struts2是基于类级别的拦截，针对每一个请求，都需要一个对应的Action来进行处理，而SpringMVC是基于方法级别的拦截，开发效率和执行效率要高于Struts2. SpringMVC的核心是一个DispatcherServlet类。与大多数javaWeb框架一样，SpringMVC所有的请求都会通过一个前端控制器Servlet，也就是DispatcherServlet DispatcherServlet的任务就是将请求发送给SpringMVC控制器，即一个Controller。控制器是一个用于处理请求的Spring组件。 通过以上内容，对SpringMVC有了一个大概的了解，接下里将进行一个简单的SpringMVC框架的配置。 配置SpringMVC补充：Servlet3.0新特性： 异步处理支持：有了该特性，Servlet 线程不再需要一直阻塞，直到业务处理完毕才能再输出响应，最后才结束该 Servlet 线程。在接收到请求之后，Servlet 线程可以将耗时的操作委派给另一个线程来完成，自己在不生成响应的情况下返回至容器。针对业务处理较耗时的情况，这将大大减少服务器资源的占用，并且提高并发处理速度。 新增的注解支持：该版本新增了若干注解，用于简化 Servlet、过滤器（Filter）和监听器（Listener）的声明，这使得 web.xml 部署描述文件从该版本开始不再是必选的了。 可插性支持：熟悉 Struts2 的开发者一定会对其通过插件的方式与包括 Spring 在内的各种常用框架的整合特性记忆犹新。将相应的插件封装成 JAR 包并放在类路径下，Struts2 运行时便能自动加载这些插件。现在 Servlet 3.0 提供了类似的特性，开发者可以通过插件的方式很方便的扩充已有 Web 应用的功能，而不需要修改原有的应用。 传统的Servlet配置方式是采用web.xml文件进行配置。但是在Servlet3的新规范中，并不推荐这种配置方式，而通过spring3.1之后的功能增强和Servlet3的新规范，可以使用一种更便捷的新方法，通过java类的方式来配置DispatcherServlet 首先，需要新建一个类，继承AbstractAnnotationConfigDispatcherServletInitializer类，我将这个类命名为MyWebAppInitializer MyWebAppInitializer.java package com.song.web.config; import org.springframework.web.servlet.support.AbstractAnnotationConfigDispatcherServletInitializer; import javax.servlet.Filter; import javax.servlet.MultipartConfigElement; import javax.servlet.ServletRegistration; public class MyWebAppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer { @Override protected Class&lt;?&gt;[] getRootConfigClasses() { return new Class&lt;?&gt;[] {RootConfig.class}; } @Override protected Class&lt;?&gt;[] getServletConfigClasses() { return new Class&lt;?&gt;[] {WebConfig.class}; } @Override protected String[] getServletMappings() { return new String[] {&quot;/&quot;}; } /** * 可用此方法配置Filter * @return */ @Override protected Filter[] getServletFilters() { return new Filter[] {}; } /** * 上传文件参数配置 * @param registration */ @Override protected void customizeRegistration(ServletRegistration.Dynamic registration) { registration.setMultipartConfig( new MultipartConfigElement(&quot;d:/tmp/&quot;,419430400,419430400,0) ); } } 下面对这个类进行说明，为什么要创建一个这样的类？在Servlet3.0的环境中，容器会在类路径中查找实现了javax.servlet.ServletContainerInitializer接口的类，如果找到了这个类，就用它来配置Servlet容器。幸运的是，Spring已经提供了这个接口的实现，那就是SpringServletContainerInitializer这个类，这个类又会反过来查找实现了WebApplicationInitializer接口的类，并将非陪的任务交给他们完成。Spring3.2之后提供了一个便利的实现，那就是AbstractAnnotationConfigDispatcherServletInitializer这个类，由于MyWebAppInitializer继承了这个类，也就同时实现了WebApplicationInitializer这个接口，所以当部署到Servlet3.0容器中的时候，容器就会自动发现它，并用来配置Servlet上下文。通过其中的方法，即可完成对DispatcherServlet的配置 下面对类中的方法进行说明 getRootConfigClasses()：返回一个Spring配置类数组，用来配置其他工具bean类，例如DataSource，Mybatis，Service类等等。 getServletConfigClasses()：返回一个springMVC配置类数组，用来配置与web相关的bean类，例如controller类等等。 AbstractAnnotationConfigDispatcherServletInitializer在初始化的时候，会自动帮我们注册DispatcherServlet类，并根据getServletConfigClasses（）提供的配置类创建servletContext，但在SpringWeb应用中，一般还会有另一个ApplicationContext，是由ContextLoaderListener创建的，其中ApplicationContext是ServletContext的父容器，也就是说ServletContext可以访问ApplicationContext中声明的bean。 除了以上简单配置外，另外springMVC所需要的各种过滤器并没有在其中进行配置，感觉这样配置的话会显得很杂乱，所以我个人是将这些过滤器在wwb.xml中进行配置，如编码过滤器配置如下： &lt;filter&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 其中RootConfig.java代码如下： package com.song.web.config; import org.springframework.context.annotation.*; import org.springframework.web.servlet.config.annotation.EnableWebMvc; /** * 声明为配置类，用于配置Spring容器 */ @Configuration /** * 导入其他配置文件，当只能通过mxl配置某些组件的时候可以考虑这种方式，此处用于引入Spring组件的相关配置 */ @ImportResource(&quot;classpath:xml/spring-mybatis.xml&quot;) /** * 配置组件扫描，自动扫描相关包下使用@Component、@Controller、@Service等注解的类，将其配置为bean组件 */ @ComponentScan(basePackages ={&quot;com.song&quot;}, excludeFilters = {@ComponentScan.Filter(type = FilterType.ANNOTATION,value = EnableWebMvc.class)}) public class RootConfig { } WebConfig.java package com.song.web.config; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.ComponentScan; import org.springframework.context.annotation.Configuration; import org.springframework.web.multipart.MultipartResolver; import org.springframework.web.multipart.support.StandardServletMultipartResolver; import org.springframework.web.servlet.ViewResolver; import org.springframework.web.servlet.config.annotation.DefaultServletHandlerConfigurer; import org.springframework.web.servlet.config.annotation.EnableWebMvc; import org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter; import org.springframework.web.servlet.view.InternalResourceViewResolver; @Configuration /*** * 启用SpringMvc的支持 */ @EnableWebMvc @ComponentScan(&quot;com.song,web&quot;) public class WebConfig extends WebMvcConfigurerAdapter{ /** * 注册一个简单的视图解析器 * @return */ @Bean public ViewResolver viewResolver(){ InternalResourceViewResolver resolver = new InternalResourceViewResolver(); resolver.setPrefix(&quot;/WEB-INF/views/&quot;); resolver.setSuffix(&quot;.jsp&quot;); resolver.setExposeContextBeansAsAttributes(true); return resolver; } /** * 用于上传操作的组件 * @return */ @Bean public MultipartResolver multipartResolver(){ return new StandardServletMultipartResolver(); } /** * 配置静态资源的处理，将静态资源的请求转发到Servlet容器中默认的Servlet上 * @param configurer */ @Override public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) { configurer.enable(); } } 以上便完成了一个简单的SpringMVC框架配置，接下来为SpringMVC配置Mybatis持久层支持 整合Mybatis框架加入Mybatis相关组件首先需要数据源，本例采用数据源为dbcp2，整个配置文件如下： spring-mybatis.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!-- 3.配置SqlSessionFactory对象 --&gt; &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;!-- 注入数据库连接池 --&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt; &lt;!-- 配置MyBaties全局配置文件:spring-mybatis.xml --&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:xml/mybatis-config.xml&quot; /&gt; &lt;!-- 扫描sql配置文件:mapper需要的xml文件，当Mapper接口和xml文件在同一个目录下时，可省略此项 --&gt; &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:com/song/web/model/*.xml&quot; /&gt; &lt;/bean&gt; &lt;!--4.配置扫描Dao接口包，动态实现Dao接口，注入到spring容器中--&gt; &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;!-- 注入sqlSessionFactory --&gt; &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot; /&gt; &lt;!-- 给出需要扫描Dao接口包 --&gt; &lt;property name=&quot;basePackage&quot; value=&quot;com.song.web.mapper&quot; /&gt; &lt;/bean&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp2.BasicDataSource&quot; destroy-method=&quot;close&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/baron&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;songjin&quot;/&gt; &lt;/bean&gt; &lt;/beans&gt; 将xml导入到前文所提到的RootConfigjava类中即可完成配置接下来需要对Mybatis进行全局的配置 mybatis-config.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt; &lt;configuration&gt; &lt;!-- 配置全局属性 --&gt; &lt;settings&gt; &lt;!-- 使用jdbc的getGeneratedKeys获取数据库自增主键值 --&gt; &lt;setting name=&quot;useGeneratedKeys&quot; value=&quot;true&quot; /&gt; &lt;!-- 使用列别名替换列名 默认:true --&gt; &lt;setting name=&quot;useColumnLabel&quot; value=&quot;true&quot; /&gt; &lt;!-- 开启驼峰命名转换:Table{create_time} -&gt; Entity{createTime} --&gt; &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot; /&gt; &lt;/settings&gt; &lt;/configuration&gt; 配置完成之后，就可以配置相应的Controller和Service进行测试了，这里就不一一详细说明了。 问题总结： mybatis设置了主键自增之后为什么仍然报错，显示主键为空？原因是mybatis的主键自增需要是基于数据库的主键自增，所以在数据库里面一定要启动主键的自增选项，这样才会生效。","tags":[{"name":"框架","slug":"框架","permalink":"https://songjin1994.github.io/tags/框架/"},{"name":"Java","slug":"Java","permalink":"https://songjin1994.github.io/tags/Java/"}]},{"title":"Struts2配置文件相关标签及其属性","date":"2016-05-09T16:00:00.000Z","path":"2016/05/10/Struts2配置文件相关标签及其属性/","text":"Struts2配置文件相关标签及其属性constantpackage:用法和java的包类似，用于区分同名的action name：包名 extends：继承的包名，一般默认为“struts-default” namespace：指定名称空间，也就是访问此包下的Action需要访问的路径 abstract：将包声明为抽象类型（即包中不包括action） action###action直接继承actionsupport类，主要实现execute（）方法路径访问先找filter，之后寻找struts配置文件中相应的namespace，如果无，法找到相应的namespace，则返回web.xml执行相应操作，如果找到了，则寻找对应的action，根据执行action后返回的String字符串，在result标签中找到对应的result视图执行 name：用于配置Action对象被请求的URL映射 class：指定Action对象的类名 method：设置请求Action对象时，调用Action对象的哪一个方法,通过method指定来实现方法调用会产生大量action实例，浪费资源，所以一般不推荐使用。一般使用动态方法调用DMI converter：指定Action对象类型转换器的类 result相关注意事项：","tags":[{"name":"框架","slug":"框架","permalink":"https://songjin1994.github.io/tags/框架/"},{"name":"Java","slug":"Java","permalink":"https://songjin1994.github.io/tags/Java/"}]},{"title":"JDBC进行数据库连接操作","date":"2016-02-12T16:00:00.000Z","path":"2016/02/13/webserve_数据库操作/","text":"JDBC进行数据库连接操作 在page指令中可以使用import导入所需要的java开发包java.sql，进行数据库开发。 查询代码如下所示 &lt;%@page contentType=&quot;text/html&quot; pageEncoding=&quot;GBK&quot; %&gt; &lt;%@page import=&quot;java.sql.*&quot; %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;jdbc编程测试&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;%! public static final String DBDRIVER=&quot;org.gjt.mm.mysql.Driver&quot;; public static final String DBURL=&quot;jdbc:mysql://localhost:3306/baron&quot;; public static final String DBUSER=&quot;root&quot;; public static final String DBPASS=&quot;mysql&quot;; %&gt; &lt;% Connection conn=null; PreparedStatement pstmt=null; ResultSet rs=null; %&gt; &lt;% try { Class.forName(DBDRIVER); conn=DriverManager.getConnection(DBURL,DBUSER,DBPASS); String sql=&quot;SELECT name,age FROM user&quot;; pstmt=conn.prepareStatement(sql); rs=pstmt.executeQuery(); while (rs.next()){ String name=rs.getString(&quot;name&quot;); int age=rs.getInt(&quot;age&quot;); %&gt; &lt;%=name%&gt;&lt;br&gt;&lt;%=age%&gt;&lt;br&gt; &lt;% } rs.close(); pstmt.close(); conn.close(); }catch (Exception e){ e.printStackTrace(); } %&gt; &lt;%=&quot;结果显示&quot;%&gt; &lt;/body&gt; &lt;/html&gt;","tags":[{"name":"web","slug":"web","permalink":"https://songjin1994.github.io/tags/web/"},{"name":"Javaweb","slug":"Javaweb","permalink":"https://songjin1994.github.io/tags/Javaweb/"},{"name":"JDBC","slug":"JDBC","permalink":"https://songjin1994.github.io/tags/JDBC/"}]}]